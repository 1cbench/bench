task,context,validation,gt_solution,run_context,output
"Создай функцию ЗаполнитьТабличнуюЧастьОстатками(ДокументОбъект), которая заполняет табличную часть документа «Заказ» «Товары» остатками из регистра «ТоварныеЗапасы» для склада и даты, заданных в документе. Отбирать только товары видом товара = Товар. Для каждой позиции остатка нужно добавить строку в табличную часть и перенести туда товар и количество.","{
  ""Documents"": [
    {
      ""id"": ""Заказ"",
      ""properties"": [
        ""Номер"": ""string"",
        ""Дата"": ""date"",
        ""Клиент"": ""Ref.Контрагенты"",
        ""Склад"": ""Ref.Склады"",
        ""Комментарий"": ""string""
      ],
      ""tabularSections"": [
        {
          ""Товары"": [
            ""Номенклатура"": ""Ref.Номенклатура"",
            ""Количество"": ""number"",
            ""Цена"": ""number"",
            ""Сумма"": ""calculated as Количество * Цена""
          ]
        }
      ]
    }
  ]
}","Функция ЗадачаРешена(ДокументОбъект) Экспорт
    // Проверяем ровно две строки и точные количества
    Если ДокументОбъект.Товары.Количество() <> 19 Тогда
        Возврат Ложь;
    КонецЕсли;

   	СуммаКоличеств = 0;
	Для каждого СтрТовар Из ДокументОбъект.Товары Цикл
	    СуммаКоличеств = СуммаКоличеств + СтрТовар.Количество;
	КонецЦикла;

	Возврат СуммаКоличеств = 299;    
	
КонецФункции
","Функция ЗаполнитьТабличнуюЧастьОстатками(ДокументОбъект)
	Запрос = Новый Запрос();
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	Т.Товар КАК Товар,
	|	Т.КоличествоОстаток КАК Количество
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(&Дата, Склад = &Склад) КАК Т
	|ГДЕ
	|	Т.Товар.Вид = ЗНАЧЕНИЕ(Перечисление.ВидыТоваров.Товар)"";    
	
	Запрос.УстановитьПараметр(""Дата"",  ДокументОбъект.Дата);   
	Запрос.УстановитьПараметр(""Склад"", ДокументОбъект.Склад);

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СтрокаТЧ = ДокументОбъект.Товары.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТЧ, Выборка);
	КонецЦикла;  
	
КонецФункции
","Функция ЗапуститьРешение() Экспорт
	ДокументОбъект = Документы.Заказ.СоздатьДокумент();	                   
	ДокументОбъект.Дата = '20250920';
	ДокументОбъект.Склад = Справочники.Склады.НайтиПоНаименованию(""Большой"");    
	ЗаполнитьТабличнуюЧастьОстатками(ДокументОбъект);
	
	Возврат ЗадачаРешена(ДокументОбъект);
КонецФункции

","// ОбщийМодуль: ЗаполнениеЗаказаОстатками (клиент-сервер)
// Назначение: заполнение табличной части ""Товары"" документа ""Заказ""
// остатками по регистру накопления ""ТоварныеЗапасы"" на дату и склад документа.

Функция ЗаполнитьТабличнуюЧастьОстатками(ДокументОбъект) Экспорт
	
	// Проверки входных данных
	Если ДокументОбъект = Неопределено Тогда
		Предупреждение(""Не передан объект документа."");
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДокументОбъект.Склад) Тогда
		Предупреждение(""В документе не указан склад. Заполнение невозможно."");
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДокументОбъект.Дата) Тогда
		Предупреждение(""В документе не указана дата. Заполнение невозможно."");
		Возврат Ложь;
	КонецЕсли;
	
	// Очистим текущие строки перед заполнением
	Если ДокументОбъект.Товары.Количество() > 0 Тогда
		ДокументОбъект.Товары.Очистить();
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Остатки.Номенклатура КАК Номенклатура,
	|	Остатки.КоличествоОстаток КАК Количество
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(&МоментВремени, Склад = &Склад) КАК Остатки
	|ГДЕ
	|	Остатки.КоличествоОстаток > 0
	|	И Остатки.Номенклатура.ВидНоменклатуры = &ВидНоменклатурыТовар
	|УПОРЯДОЧИТЬ ПО
	|	Номенклатура"";
	
	// Параметры запроса
	Запрос.УстановитьПараметр(""МоментВремени"", ДокументОбъект.Дата);
	Запрос.УстановитьПараметр(""Склад"", ДокументОбъект.Склад);
	
	// Отбор только по номенклатуре вида ""Товар""
	// Предполагается наличие перечисления ВидыНоменклатуры.Товар
	// При необходимости адаптируйте под вашу конфигурацию (например, ЭтоУслуга = ЛОЖЬ).
	Запрос.УстановитьПараметр(""ВидНоменклатурыТовар"", Перечисления.ВидыНоменклатуры.Товар);
	
	Попытка
		Результат = Запрос.Выполнить();
	Исключение
		Предупреждение(""Не удалось выполнить запрос к регистру 'ТоварныеЗапасы'. Проверьте структуру регистра и параметры отбора."");
		Возврат Ложь;
	КонецПопытки;
	
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		НоваяСтрока = ДокументОбъект.Товары.Добавить();
		НоваяСтрока.Номенклатура = Выборка.Номенклатура;
		НоваяСтрока.Количество   = Выборка.Количество;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции"
"Создай функцию ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата) которая выводит в табличный документ задолженность по контрагентам из регистра Взаиморасчеты на дату. В макете есть секции Шапка и Строка, в секции строка есть параметры “Контрагент” и “Задолженность”","{
  ""AccumulationRegisters"": [
    {
      ""id"": ""Взаиморасчеты"",
      ""name"": ""Взаиморасчеты"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        },
        {
          ""id"": ""Валюта"",
          ""name"": ""Валюта"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Валюты""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Сумма"",
          ""name"": ""Сумма"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}","Функция ЗадачаРешена(ТабДокумент) Экспорт

	Если ТабДокумент.ВысотаТаблицы < 13 Тогда 
		Возврат Ложь;
	КонецЕсли;

	// Получаем значения из первых двух строк данных (индексация с 1)
	Значение1 = ТабДокумент.Область(""R1C1"").Текст;  
	Значение2 = ТабДокумент.Область(""R3C1"").Текст;  
	Значение3 = ТабДокумент.Область(""R3C2"").Текст;

	Если Значение1 <> ""Контрагент"" Или Значение2 <> ""Магазин """"Продукты"""""" ИЛИ Значение3 <> ""323390"" Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Истина;

КонецФункции


","
Функция ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата) Экспорт

	// Граница периода: берём остатки на конец дня указанной даты
	ДатаКон = КонецДня(Дата);

	// Запрос по виртуальной таблице Остатки регистра ""Взаиморасчеты"".
	// Суммируем по контрагенту (валюту игнорируем — если нужно раздельно по валютам,
	// добавьте поле Валюта в выборку/группировку и параметр в макет).
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Остатки.Контрагент КАК Контрагент,
	|	СУММА(Остатки.СуммаОстаток) КАК Задолженность
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&ДатаКон, ) КАК Остатки
	|СГРУППИРОВАТЬ ПО
	|	Остатки.Контрагент
	|ИМЕЮЩИЕ
	|	СУММА(Остатки.СуммаОстаток) <> 0
	|УПОРЯДОЧИТЬ ПО
	|	Контрагент"";

	Запрос.УстановитьПараметр(""ДатаКон"", ДатаКон);

	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();

	// Подготовка табличного документа
	ТабДокумент.Очистить();

	Если Макет <> Неопределено Тогда
		ОбластьШапка = Макет.ПолучитьОбласть(""Шапка"");
		Если ОбластьШапка <> Неопределено Тогда
			ТабДокумент.Вывести(ОбластьШапка);
		КонецЕсли;
	КонецЕсли;

	ЕстьДанные = Ложь;

	Пока Выборка.Следующий() Цикл
		ЕстьДанные = Истина;

		ОбластьСтрока = Макет.ПолучитьОбласть(""Строка"");
		Если ОбластьСтрока = Неопределено Тогда
			ВызватьИсключение ""В макете отсутствует секция 'Строка'."";
		КонецЕсли;

		ОбластьСтрока.Параметры.Контрагент    = Выборка.Контрагент;
		ОбластьСтрока.Параметры.Задолженность = Выборка.Задолженность;

		ТабДокумент.Вывести(ОбластьСтрока);
	КонецЦикла;

	Возврат ТабДокумент;

КонецФункции
","Функция ЗапуститьРешение() Экспорт
	Макет = ЭтотОбъект.ПолучитьМакет(""Задача3"");	                   
    ТабДокумент = Новый ТабличныйДокумент();   
	Дата = '20250920';
	ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата);
	
	Возврат ЗадачаРешена(ТабДокумент);
КонецФункции

","// Функция выводит в табличный документ задолженность по контрагентам из регистра ""Взаиморасчеты"" на указанную дату
// Параметры:
//  - ТабДокумент (ТабличныйДокумент) - целевой табличный документ для вывода
//  - Макет (Макет) - макет с областями ""Шапка"" и ""Строка""; в ""Строка"" должны быть параметры ""Контрагент"" и ""Задолженность""
//  - Дата (Дата) - дата, на которую рассчитываются остатки
//
// Возвращает: ТабличныйДокумент
//
Функция ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата) Экспорт

	// Защитные проверки типов (по возможности)
	Если ТипЗнч(ТабДокумент) <> Тип(""ТабличныйДокумент"") Тогда
		ВызватьИсключение ""Параметр ТабДокумент должен быть типа ТабличныйДокумент."";
	КонецЕсли;
	Если ТипЗнч(Макет) <> Тип(""Макет"") Тогда
		ВызватьИсключение ""Параметр Макет должен быть типа Макет."";
	КонецЕсли;
	Если ТипЗнч(Дата) <> Тип(""Дата"") Тогда
		ВызватьИсключение ""Параметр Дата должен быть типа Дата."";
	КонецЕсли;

	// Очистим документ и выведем шапку
	ТабДокумент.Очистить();

	ОбластьШапка = Макет.ПолучитьОбласть(""Шапка"");
	// Если в макете есть параметр Дата (или аналогичный), заполним его
	ОбластьШапка.Параметры.Вставить(""Дата"", Дата);
	ТабДокумент.Вывести(ОбластьШапка);

	// Подготовим запрос к виртуальной таблице ОстаткиИОбороты
	// Период с минимальной даты по конец указанного дня
	НачПериода  = Дата(1, 1, 1);
	КонецПериода = КонецДня(Дата);

	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Остатки.Контрагент КАК Контрагент,
	|	СУММА(Остатки.СуммаКонечныйОстаток) КАК Задолженность
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.ОстаткиИОбороты(&НачПериода, &КонецПериода) КАК Остатки
	|СГРУППИРОВАТЬ ПО
	|	Остатки.Контрагент
	|ИМЕЮЩИЕ
	|	СУММА(Остатки.СуммаКонечныйОстаток) <> 0
	|УПОРЯДОЧИТЬ ПО
	|	Контрагент"";

	Запрос.УстановитьПараметр(""НачПериода"", НачПериода);
	Запрос.УстановитьПараметр(""КонецПериода"", КонецПериода);

	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();

	ОбластьСтрока = Макет.ПолучитьОбласть(""Строка"");

	Пока Выборка.Следующий() Цикл
		ОбластьСтрока.Параметры.Вставить(""Контрагент"",     Выборка.Контрагент);
		ОбластьСтрока.Параметры.Вставить(""Задолженность"",  Выборка.Задолженность);
		ТабДокумент.Вывести(ОбластьСтрока);
	КонецЦикла;

	Возврат ТабДокумент;

КонецФункции"
"Создай функцию, которая устанавливает во всех строках ТЧ «Товары» значение поля «СкладСтроки» равным реквизиту документа «Склад».","{
  ""Documents"": [
    {
      ""id"": ""Заказ"",
      ""properties"": [
        ""Номер"": ""string"",
        ""Дата"": ""date"",
        ""Клиент"": ""Ref.Контрагенты"",
        ""Склад"": ""Ref.Склады"",
        ""Комментарий"": ""string""
      ],
      ""tabularSections"": [
        {
          ""Товары"": [
            ""Номенклатура"": ""Ref.Номенклатура"",
            ""Количество"": ""number"",
            ""Цена"": ""number"",
            ""Сумма"": ""calculated as Количество * Цена""
          ]
        }
      ]
    }
  ]
}","Функция ЗадачаРешена(ТабДокумент) Экспорт

	Если ТабДокумент.ВысотаТаблицы < 13 Тогда 
		Возврат Ложь;
	КонецЕсли;

	// Получаем значения из первых двух строк данных (индексация с 1)
	Значение1 = ТабДокумент.Область(""R1C1"").Текст;  
	Значение2 = ТабДокумент.Область(""R3C1"").Текст;  
	Значение3 = ТабДокумент.Область(""R3C2"").Текст;

	Если Значение1 <> ""Контрагент"" Или Значение2 <> ""Магазин """"Продукты"""""" ИЛИ Значение3 <> ""323391"" Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Истина;

КонецФункции


","
Функция ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата) Экспорт

	// Граница периода: берём остатки на конец дня указанной даты
	ДатаКон = КонецДня(Дата);

	// Запрос по виртуальной таблице Остатки регистра ""Взаиморасчеты"".
	// Суммируем по контрагенту (валюту игнорируем — если нужно раздельно по валютам,
	// добавьте поле Валюта в выборку/группировку и параметр в макет).
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Остатки.Контрагент КАК Контрагент,
	|	СУММА(Остатки.СуммаОстаток) КАК Задолженность
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&ДатаКон, ) КАК Остатки
	|СГРУППИРОВАТЬ ПО
	|	Остатки.Контрагент
	|ИМЕЮЩИЕ
	|	СУММА(Остатки.СуммаОстаток) <> 0
	|УПОРЯДОЧИТЬ ПО
	|	Контрагент"";

	Запрос.УстановитьПараметр(""ДатаКон"", ДатаКон);

	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();

	// Подготовка табличного документа
	ТабДокумент.Очистить();

	Если Макет <> Неопределено Тогда
		ОбластьШапка = Макет.ПолучитьОбласть(""Шапка"");
		Если ОбластьШапка <> Неопределено Тогда
			ТабДокумент.Вывести(ОбластьШапка);
		КонецЕсли;
	КонецЕсли;

	ЕстьДанные = Ложь;

	Пока Выборка.Следующий() Цикл
		ЕстьДанные = Истина;

		ОбластьСтрока = Макет.ПолучитьОбласть(""Строка"");
		Если ОбластьСтрока = Неопределено Тогда
			ВызватьИсключение ""В макете отсутствует секция 'Строка'."";
		КонецЕсли;

		ОбластьСтрока.Параметры.Контрагент    = Выборка.Контрагент;
		ОбластьСтрока.Параметры.Задолженность = Выборка.Задолженность;

		ТабДокумент.Вывести(ОбластьСтрока);
	КонецЦикла;

	Возврат ТабДокумент;

КонецФункции
","Функция ЗапуститьРешение() Экспорт
	Макет = ЭтотОбъект.ПолучитьМакет(""Задача3"");	                   
    ТабДокумент = Новый ТабличныйДокумент();   
	Дата = '20250920';
	ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата);
	
	Возврат ЗадачаРешена(ТабДокумент);
КонецФункции

","// Модуль объекта документа ""Заказ""

// Функция устанавливает во всех строках ТЧ ""Товары"" значение поля ""СкладСтроки""
// равным реквизиту документа ""Склад"". Возвращает количество измененных строк.
Функция УстановитьСкладВСтрокахТоваров(Знач НовыйСклад = Неопределено) Экспорт
	
	// Если параметр не передан, берем склад из шапки документа
	Если НовыйСклад = Неопределено Тогда
		НовыйСклад = Склад;
	КонецЕсли;
	
	// Если склад не заполнен, ничего не делаем
	Если НовыйСклад = Неопределено Тогда
		Возврат 0;
	КонецЕсли;
	
	Если Товары.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	ИзмененоСтрок = 0;
	
	Для Каждого СтрокаТовары Из Товары Цикл
		// Избегаем лишних присваиваний
		Если НЕ ЗначенияРавны(СтрокаТовары.СкладСтроки, НовыйСклад) Тогда
			СтрокаТовары.СкладСтроки = НовыйСклад;
			ИзмененоСтрок = ИзмененоСтрок + 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИзмененоСтрок;
	
КонецФункции

// Обеспечиваем целостность данных при записи
Процедура ПередЗаписью(Отказ, РежимЗаписи)
	УстановитьСкладВСтрокахТоваров();
КонецПроцедуры



// ----------------------------
// Модуль формы документа ""Заказ"" (опционально, для онлайн-синхронизации на форме)
// ----------------------------

Процедура СкладПриИзменении(Элемент)
	Если Объект <> Неопределено Тогда
		// Обновляем строки при изменении склада пользователем
		Объект.УстановитьСкладВСтрокахТоваров();
		// Обновляем отображение табличной части на форме
		Если ЭлементыФормы.Свойство(""Товары"") Тогда
			ЭлементыФормы.Товары.Обновить();
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры"
Создай функцию НеУстановленыЦены(Поставщик) которая возвращает СписокЗначений с элементами справочника Товары у которых Поставщик = Поставщик и нет записи в регистре сведений ЦеныТоваров,"{
  ""InformationRegisters"": [
    {
      ""id"": ""ЦеныТоваров"",
      ""name"": ""Цены товаров"",
      ""InformationRegisterPeriodicity"": ""Day"",
      ""WriteMode"": ""Independent"",
      ""Dimensions"": [
        {
          ""id"": ""Товар"",
          ""name"": ""Товар"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Товары""
            }
          ]
        },
        {
          ""id"": ""ВидЦен"",
          ""name"": ""Вид цен"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.ВидыЦен""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Цена"",
          ""name"": ""Цена"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}","Функция ЗадачаРешена(СписокТоваров, ОжидаемыеТовары) Экспорт

	// Проверяем тип результата
	Если ТипЗнч(СписокТоваров) <> Тип(""СписокЗначений"") Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем количество элементов
	Если СписокТоваров.Количество() <> ОжидаемыеТовары.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем, что все ожидаемые товары присутствуют в списке
	Для Каждого ОжидаемыйТовар Из ОжидаемыеТовары Цикл
		ЭлементСписка = СписокТоваров.НайтиПоЗначению(ОжидаемыйТовар.Значение);
		Если ЭлементСписка = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	// Проверяем, что в списке нет лишних товаров
	Для Каждого ЭлементСписка Из СписокТоваров Цикл
		Найден = Ложь;
		Для Каждого ОжидаемыйТовар Из ОжидаемыеТовары Цикл
			Если ЭлементСписка.Значение = ОжидаемыйТовар.Значение Тогда
				Найден = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если НЕ Найден Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина;

КонецФункции
","Функция НеУстановленыЦены(Поставщик) Экспорт

 // Запрос для получения товаров поставщика, у которых нет записей в регистре ЦеныТоваров
 Запрос = Новый Запрос;
 Запрос.Текст =
 ""ВЫБРАТЬ
 | Товары.Ссылка КАК Товар
 |ИЗ
 | Справочник.Товары КАК Товары
 |  ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЦеныТоваров КАК ЦеныТоваров
 |  ПО Товары.Ссылка = ЦеныТоваров.Товар
 |ГДЕ
 | Товары.Поставщик = &Поставщик
 | И Товары.ЭтоГруппа = ЛОЖЬ
 | И НЕ Товары.ПометкаУдаления
 | И ЦеныТоваров.Товар ЕСТЬ NULL
 |УПОРЯДОЧИТЬ ПО
 | Товар"";

 Запрос.УстановитьПараметр(""Поставщик"", Поставщик);

 Результат = Запрос.Выполнить();
 Выборка = Результат.Выбрать();

 // Создаём список значений для возврата
 СписокТоваров = Новый СписокЗначений;

 Пока Выборка.Следующий() Цикл
  СписокТоваров.Добавить(Выборка.Товар);
 КонецЦикла;

 Возврат СписокТоваров;

КонецФункции
","Функция ЗапуститьРешение() Экспорт

 	// Подготовка тестовых данных: создаём поставщика
 	Поставщик = Справочники.Контрагенты.НайтиПоНаименованию(""Тестовый поставщик"");

	Если Поставщик.Пустая() Тогда
		Поставщик = Справочники.Контрагенты.СоздатьЭлемент();
		Поставщик.Наименование = ""Тестовый поставщик"";
		Поставщик.Записать();
		Поставщик = Поставщик.Ссылка; 
	КонецЕсли;    
	
	ДругойПоставщик = Справочники.Контрагенты.НайтиПоНаименованию(""Другой поставщик"");

	Если ДругойПоставщик.Пустая() Тогда
		ДругойПоставщик = Справочники.Контрагенты.СоздатьЭлемент();
		ДругойПоставщик.Наименование = ""Другой поставщик"";
		ДругойПоставщик.Записать();
		ДругойПоставщик = Поставщик.Ссылка; 
	КонецЕсли;


 // Создаём вид цен для теста (если нужен)
 ВидЦен = Справочники.ВидыЦен.НайтиПоНаименованию(""Базовая"");

 Если ВидЦен.Пустая() Тогда
  ВидЦен = Справочники.ВидыЦен.СоздатьЭлемент();
  ВидЦен.Наименование = ""Базовая"";
  ВидЦен.Записать(); 
  ВидЦен = ВидЦен.Ссылка; 
 КонецЕсли;

 // Создаём товары для теста
 // Товар 1 - с ценой (не должен попасть в список)
 Товар1 = Справочники.Товары.СоздатьЭлемент();
 Товар1.Наименование = ""Товар с ценой"";
 Товар1.Поставщик = Поставщик;
 Товар1.Записать();

 МенеджерЦены1 = РегистрыСведений.ЦеныТоваров.СоздатьМенеджерЗаписи();
 МенеджерЦены1.Период = ТекущаяДатаСеанса();
 МенеджерЦены1.Товар = Товар1.Ссылка;
 МенеджерЦены1.ВидЦен = ВидЦен;
 МенеджерЦены1.Цена = 100;
 МенеджерЦены1.Записать();

 // Товар 2 - без цены (должен попасть в список)
 Товар2 = Справочники.Товары.СоздатьЭлемент();
 Товар2.Наименование = ""Товар без цены 1"";
 Товар2.Поставщик = Поставщик;
 Товар2.Записать();

 // Товар 3 - без цены (должен попасть в список)
 Товар3 = Справочники.Товары.СоздатьЭлемент();
 Товар3.Наименование = ""Товар без цены 2"";
 Товар3.Поставщик = Поставщик;
 Товар3.Записать();

 Товар4 = Справочники.Товары.СоздатьЭлемент();
 Товар4.Наименование = ""Товар другого поставщика"";
 Товар4.Поставщик = ДругойПоставщик;
 Товар4.Записать();

 // Формируем ожидаемый список товаров без цен
 ОжидаемыеТовары = Новый СписокЗначений;
 ОжидаемыеТовары.Добавить(Товар2.Ссылка);
 ОжидаемыеТовары.Добавить(Товар3.Ссылка);

 // Вызов функции задачи
 СписокТоваров = НеУстановленыЦены(Поставщик);

 // Вызов функции валидатора для проверки решения задачи
 РезультатПроверки = ЗадачаРешена(СписокТоваров, ОжидаемыеТовары);

 // Удаление тестовых данных
 // Удаляем запись регистра цен
 МенеджерУдаления = РегистрыСведений.ЦеныТоваров.СоздатьМенеджерЗаписи();
 МенеджерУдаления.Период = МенеджерЦены1.Период;
 МенеджерУдаления.Товар = Товар1.Ссылка;
 МенеджерУдаления.ВидЦен = ВидЦен;
 МенеджерУдаления.Удалить();

 // Удаляем товары
 Товар1.Удалить();
 Товар2.Удалить();
 Товар3.Удалить();
 Товар4.Удалить();

 // Удаляем контрагентов
 Поставщик.ПолучитьОбъект().Удалить();
 ДругойПоставщик.ПолучитьОбъект().Удалить();

 // Удаляем вид цен
 ВидЦен.ПолучитьОбъект().Удалить();

 Возврат РезультатПроверки;

КонецФункции
","Функция НеУстановленыЦены(Поставщик) Экспорт
	// Возвращает СписокЗначений со ссылками на товары указанного поставщика,
	// для которых нет ни одной записи в регистре сведений ""ЦеныТоваров"".
	
	Список = Новый СписокЗначений;
	
	Если НЕ ЗначениеЗаполнено(Поставщик) Тогда
		Возврат Список;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ|"" +
	""	Товары.Ссылка КАК Товар|"" +
	""ИЗ|"" +
	""	Справочник.Товары КАК Товары|"" +
	""ГДЕ|"" +
	""	Товары.Поставщик = &Поставщик|"" +
	""	И НЕ Товары.ПометкаУдаления|"" +
	""	И НЕ СУЩЕСТВУЕТ(|"" +
	""		ВЫБРАТЬ ПЕРВЫЕ 1|"" +
	""			Цены.Товар|"" +
	""		ИЗ|"" +
	""			РегистрСведений.ЦеныТоваров КАК Цены|"" +
	""		ГДЕ|"" +
	""			Цены.Товар = Товары.Ссылка)"";
	
	Запрос.УстановитьПараметр(""Поставщик"", Поставщик);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		Список.Добавить(Выборка.Товар);
	КонецЦикла;
	
	Возврат Список;
КонецФункции"
"Создай функцию ВыгрузитьОстаткиСклада(Склад, МинимальныйОстаток, ФайлJson), которая получает остаки товаров склада на текущую дату из регистра ТоварныеЗапасы у которых остаток больше или равен значению МинимальныйОстаток. Записать файл в json формате как список с полями ""Товар_Код"", ""Товар_Наименование"", ""Остаток"" (число, округленное до целого). Строки списка должны быть упорядочены по возрастанию поля Товар_Код","{
  ""AccumulationRegisters"": [
    {
      ""id"": ""ТоварныеЗапасы"",
      ""name"": ""Товарные запасы"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Товар"",
          ""name"": ""Товар"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Товары""
            }
          ]
        },
        {
          ""id"": ""Склад"",
          ""name"": ""Склад"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Склады""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Количество"",
          ""name"": ""Количество"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}","Функция ЗадачаРешена(ФайлJson) Экспорт
	
	ОжидаемыеДанные = Новый Массив;

	// Только товары с остатком >= 60
	СтрокаТовар = Новый Структура;
	СтрокаТовар.Вставить(""Товар_Код"", ""000000026"");
	СтрокаТовар.Вставить(""Товар_Наименование"", ""Молоко"");
	СтрокаТовар.Вставить(""Остаток"", 100);
	ОжидаемыеДанные.Добавить(СтрокаТовар);    
	
	СтрокаТовар = Новый Структура;
	СтрокаТовар.Вставить(""Товар_Код"", ""000000032"");
	СтрокаТовар.Вставить(""Товар_Наименование"", ""Торт"");
	СтрокаТовар.Вставить(""Остаток"", 100);
	ОжидаемыеДанные.Добавить(СтрокаТовар);

	СтрокаТовар = Новый Структура;
	СтрокаТовар.Вставить(""Товар_Код"", ""000000033"");
	СтрокаТовар.Вставить(""Товар_Наименование"", ""VekoNT02"");
	СтрокаТовар.Вставить(""Остаток"", 195);
	ОжидаемыеДанные.Добавить(СтрокаТовар);

	// Проверяем существование файла
	ФайлОбъект = Новый Файл(ФайлJson);
	Если НЕ ФайлОбъект.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;

	// Читаем JSON из файла
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьФайл(ФайлJson);
	МассивДанных = ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();

	// Проверяем тип результата
	Если ТипЗнч(МассивДанных) <> Тип(""Массив"") Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем количество элементов
	Если МассивДанных.Количество() <> 4 Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем каждый элемент
	Для Индекс = 0 По 2 Цикл
		ФактическаяСтрока = МассивДанных[Индекс];
		ОжидаемаяСтрока = ОжидаемыеДанные[Индекс];

		// Проверяем наличие обязательных полей
		Если НЕ ФактическаяСтрока.Свойство(""Товар_Код"")
			ИЛИ НЕ ФактическаяСтрока.Свойство(""Товар_Наименование"")
			ИЛИ НЕ ФактическаяСтрока.Свойство(""Остаток"") Тогда
			Возврат Ложь;
		КонецЕсли;

		// Проверяем значения полей
		Если ФактическаяСтрока.Товар_Код <> ОжидаемаяСтрока.Товар_Код
			ИЛИ ФактическаяСтрока.Товар_Наименование <> ОжидаемаяСтрока.Товар_Наименование
			ИЛИ ФактическаяСтрока.Остаток <> ОжидаемаяСтрока.Остаток Тогда
			Возврат Ложь;
		КонецЕсли;

		// Проверяем, что остаток - целое число
		Если ФактическаяСтрока.Остаток <> Окр(ФактическаяСтрока.Остаток, 0) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина;

КонецФункции
","Функция ВыгрузитьОстаткиСклада(Склад, МинимальныйОстаток, ФайлJson) Экспорт

	// Запрос для получения остатков товаров на складе
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Остатки.Товар.Код КАК Товар_Код,
	|	Остатки.Товар.Наименование КАК Товар_Наименование,
	|	Остатки.КоличествоОстаток КАК Остаток
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(&ТекущаяДата, Склад = &Склад) КАК Остатки
	|ГДЕ
	|	Остатки.КоличествоОстаток >= &МинимальныйОстаток
	|УПОРЯДОЧИТЬ ПО
	|	Товар_Код"";

	Запрос.УстановитьПараметр(""ТекущаяДата"", ТекущаяДатаСеанса());
	Запрос.УстановитьПараметр(""Склад"", Склад);
	Запрос.УстановитьПараметр(""МинимальныйОстаток"", МинимальныйОстаток);

	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();

	// Формируем массив для JSON
	МассивДанных = Новый Массив;

	Пока Выборка.Следующий() Цикл
		СтрокаДанных = Новый Структура;
		СтрокаДанных.Вставить(""Товар_Код"", Выборка.Товар_Код);
		СтрокаДанных.Вставить(""Товар_Наименование"", Выборка.Товар_Наименование);
		СтрокаДанных.Вставить(""Остаток"", Окр(Выборка.Остаток, 0, РежимОкругления.Окр15как20));

		МассивДанных.Добавить(СтрокаДанных);
	КонецЦикла;

	// Записываем JSON в файл
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ОткрытьФайл(ФайлJson);
	ЗаписатьJSON(ЗаписьJSON, МассивДанных);
	ЗаписьJSON.Закрыть();

	Возврат Истина;

КонецФункции
","Функция ЗапуститьРешение() Экспорт

	// Подготовка тестовых данных: создаём склад
	Склад = Справочники.Склады.НайтиПоНаименованию(""Склад отдела продаж"");

	// Формируем ожидаемые данные (минимальный остаток = 10)
	МинимальныйОстаток = 60; 
	
	// Путь к файлу JSON
	ФайлJson = ПолучитьИмяВременногоФайла(""json"");

	// Вызов функции задачи
	ВыгрузитьОстаткиСклада(Склад, МинимальныйОстаток, ФайлJson);

	// Вызов функции валидатора для проверки решения задачи
	РезультатПроверки = ЗадачаРешена(ФайлJson);

	// Удаляем временный файл JSON
	Попытка
		УдалитьФайлы(ФайлJson);
	Исключение
		// Игнорируем ошибки удаления файла
	КонецПопытки;

	Возврат РезультатПроверки;

КонецФункции
","Функция ВыгрузитьОстаткиСклада(Склад, МинимальныйОстаток, ФайлJson) Экспорт

	// Проверки параметров
	Если Не ЗначениеЗаполнено(Склад) Тогда
		ВызватьИсключение ""Не указан параметр 'Склад'."";
	КонецЕсли;
	
	Если МинимальныйОстаток = Неопределено Тогда
		МинимальныйОстаток = 0;
	КонецЕсли;
	
	// Запрос остатков на текущую дату по указанному складу
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Остатки.Товар.Код КАК Товар_Код,
	|	Остатки.Товар.Наименование КАК Товар_Наименование,
	|	Остатки.КоличествоОстаток КАК Остаток
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(&Момент, Склад = &Склад) КАК Остатки
	|ГДЕ
	|	Остатки.КоличествоОстаток >= &МинОстаток
	|УПОРЯДОЧИТЬ ПО
	|	Товар_Код"";
	
	Запрос.УстановитьПараметр(""Момент"", ТекущаяДата());
	Запрос.УстановитьПараметр(""Склад"", Склад);
	Запрос.УстановитьПараметр(""МинОстаток"", МинимальныйОстаток);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// Подготовка записи JSON
	ПотокЗаписи = Неопределено;
	ЗаписьJSON = Неопределено;
	Попытка
		ПотокЗаписи = Новый ЗаписьФайла(ФайлJson, КодировкаТекста.UTF8);
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьПоток(ПотокЗаписи);
		
		ЗаписьJSON.ЗаписатьНачалоМассива();
		
		Для Каждого Стр Из Выборка Цикл
			ЗаписьJSON.ЗаписатьНачалоОбъекта();
			ЗаписьJSON.ЗаписатьИмяЗначение(""Товар_Код"", Стр.Товар_Код);
			ЗаписьJSON.ЗаписатьИмяЗначение(""Товар_Наименование"", Стр.Товар_Наименование);
			ЗаписьJSON.ЗаписатьИмяЗначение(""Остаток"", Окр(Стр.Остаток, 0));
			ЗаписьJSON.ЗаписатьКонецОбъекта();
		КонецЦикла;
		
		ЗаписьJSON.ЗаписатьКонецМассива();
		
		ЗаписьJSON.Закрыть();
		ПотокЗаписи.Закрыть();
	Исключение
		Если ТипЗнч(ЗаписьJSON) = Тип(""ЗаписьJSON"") Тогда
			Попытка ЗаписьJSON.Закрыть(); КонецПопытки;
		КонецЕсли;
		Если ТипЗнч(ПотокЗаписи) = Тип(""ЗаписьФайла"") Тогда
			Попытка ПотокЗаписи.Закрыть(); КонецПопытки;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;

КонецФункции"
"создай функцию ПросроченныеДолги(Дата, МинДолг, СрокДолга), которая возвращает таблицу значений с контрагентами, 
у которых на заданную дату есть долг больше МинДолг, и этот долг, или его часть, образовался более СрокДолга дней назад. Задолженность смотреть в регистре накопления Взаиморасчеты.
В таблице должны быть колонки: Контрагент, ДолгВсего, ДолгПросроченный, ДатаОбразованияДолга.","{
  ""AccumulationRegisters"": [
    {
      ""id"": ""Взаиморасчеты"",
      ""name"": ""Взаиморасчеты"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        },
        {
          ""id"": ""Валюта"",
          ""name"": ""Валюта"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Валюты""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Сумма"",
          ""name"": ""Сумма"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}","Функция ЗадачаРешена(РезультатТаблица) Экспорт

 // Ожидаемые значения для проверки (схематично)
	ОжидаемоеКоличествоСтрок = 2; // Количество контрагентов с просроченными долгами
	ОжидаемыйКонтрагент2 = Справочники.Контрагенты.НайтиПоНаименованию(""Попов Б.В. ИЧП""); 
	ОжидаемыйКонтрагент1 = Справочники.Контрагенты.НайтиПоНаименованию(""Шлюзовая ООО""); 
	
	// Проверяем, что результат является таблицей значений
	Если ТипЗнч(РезультатТаблица) <> Тип(""ТаблицаЗначений"") Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем количество строк в результате
	Если РезультатТаблица.Количество() <> ОжидаемоеКоличествоСтрок Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем наличие необходимых колонок
	Попытка
		Колонки = РезультатТаблица.Колонки;
		Если Колонки.Найти(""Контрагент"") = Неопределено
			Или Колонки.Найти(""ДолгВсего"") = Неопределено    
			Или Колонки.Найти(""ДолгПросроченный"") = Неопределено
			Или Колонки.Найти(""ДатаОбразованияДолга"") = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	Исключение
		Возврат Ложь;
	КонецПопытки;

	// Проверяем значения в первой строке
	Если РезультатТаблица.Количество() >= 1 Тогда
		Строка = РезультатТаблица[0];

		Если Строка.Контрагент <> ОжидаемыйКонтрагент1 
			ИЛИ Строка.ДолгВсего <> 697169.64      
			ИЛИ Строка.ДолгПросроченный <> 697169.64
			ИЛИ Строка.ДатаОбразованияДолга <> '20230502'
			Тогда
			Возврат Ложь;
		КонецЕсли;

	КонецЕсли;

	// Проверяем значения во второй строке
	Если РезультатТаблица.Количество() >= 2 Тогда
		Строка = РезультатТаблица[1];      
		Если Строка.Контрагент <> ОжидаемыйКонтрагент2 
			ИЛИ Строка.ДолгВсего <> 18300      
			ИЛИ Строка.ДолгПросроченный <> 10300
			ИЛИ Строка.ДатаОбразованияДолга <> '20230603'
			Тогда
			Возврат Ложь;
		КонецЕсли;


	КонецЕсли;

	Возврат Истина;

КонецФункции
","Функция ПросроченныеДолги(Дата, МинДолг, СрокДолга) Экспорт

	// Определяем граничную дату для выборки остатков
	ДатаКон = КонецДня(Дата);

	// Определяем дату, ранее которой долг считается просроченным
	ДатаПросрочки = Дата - СрокДолга * 86400; // СрокДолга в днях переводим в секунды

	// Запрос для получения контрагентов с просроченными долгами
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Остатки.Контрагент КАК Контрагент,
	|	-Остатки.СуммаОстаток КАК Долг
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&ДатаКон, ) КАК Остатки
	|ГДЕ
	|	-Остатки.СуммаОстаток > &МинДолг
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Движения.Период КАК Период,
	|	Движения.Контрагент КАК Контрагент,
	|	Движения.Сумма КАК Сумма
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты КАК Движения
	|ГДЕ
	|	Движения.ВидДвижения = ЗНАЧЕНИЕ(ВидДвиженияНакопления.Расход)
	|	И Движения.Период <= &ДатаКон
	|
	|УПОРЯДОЧИТЬ ПО
	|	Период УБЫВ"";

	Запрос.УстановитьПараметр(""ДатаКон"", ДатаКон);
	Запрос.УстановитьПараметр(""МинДолг"", МинДолг);
	Запрос.УстановитьПараметр(""ДатаПросрочки"", ДатаПросрочки);   
	
	// Создаем таблицу значений для результата
	РезультатТаблица = Новый ТаблицаЗначений;
	РезультатТаблица.Колонки.Добавить(""Контрагент"", Новый ОписаниеТипов(""СправочникСсылка.Контрагенты""));
	РезультатТаблица.Колонки.Добавить(""ДолгВсего"", Новый ОписаниеТипов(""Число""));  
	РезультатТаблица.Колонки.Добавить(""ДолгПросроченный"", Новый ОписаниеТипов(""Число""));
	РезультатТаблица.Колонки.Добавить(""ДатаОбразованияДолга"", Новый ОписаниеТипов(""Дата""));

	РезультатВыполненияПакета = Запрос.ВыполнитьПакет();
	ТаблицаДолгов = РезультатВыполненияПакета[0].Выгрузить();   
	ТаблицаДвижений = РезультатВыполненияПакета[1].Выгрузить();
	
	Для каждого СтрокаДолг Из ТаблицаДолгов Цикл
	    Движения = ТаблицаДвижений.НайтиСтроки(Новый Структура(""Контрагент"", СтрокаДолг.Контрагент));
		НакопленныйДолг = 0;  
		ПросроченныйДолг = 0;
		Для каждого СтрокаДвижения Из Движения Цикл
		   	НакопленныйДолг = НакопленныйДолг + СтрокаДвижения.Сумма; 
			
			Если НачалоДня(СтрокаДвижения.Период) <= ДатаПросрочки Тогда
				ПросроченныйДолг = ПросроченныйДолг + СтрокаДвижения.Сумма; 
			КонецЕсли;                         
			
			Если НакопленныйДолг >= СтрокаДолг.Долг Тогда			
				Прервать;				
			КонецЕсли; 
		
		КонецЦикла; 
		
		Если СтрокаДвижения.Период < ДатаПросрочки Тогда
		
			НоваяСтрока = РезультатТаблица.Добавить();
			НоваяСтрока.Контрагент = СтрокаДолг.Контрагент;
			НоваяСтрока.ДолгВсего = СтрокаДолг.Долг;  
			НоваяСтрока.ДолгПросроченный = Мин(ПросроченныйДолг, СтрокаДолг.Долг);
			НоваяСтрока.ДатаОбразованияДолга = НачалоДня(СтрокаДвижения.Период);	
		
		КонецЕсли;
			
	КонецЦикла;

	Возврат РезультатТаблица;

КонецФункции
","Функция ЗапуститьРешение() Экспорт    

	РезультатТаблица = ПросроченныеДолги('20230704', 10000, 30);

	// Вызываем функцию валидатора для проверки решения задачи
	РезультатПроверки = ЗадачаРешена(РезультатТаблица);

	Возврат РезультатПроверки;

КонецФункции
","// Функция возвращает таблицу значений с колонками:
// Контрагент, ДолгВсего, ДолгПросроченный, ДатаОбразованияДолга.
// Логика:
// - ДолгВсего берется как остаток по регистру на конец указанной даты.
// - ДолгПросроченный считается как максимальное из 0 и (Остаток на границе просрочки - суммарные погашения после этой границы до даты).
//   Граница просрочки = начало дня (Дата - СрокДолга дней).
// - ДатаОбразованияДолга устанавливается равной границе просрочки, если есть просроченная часть (иначе NULL).
//
// Предполагается, что положительный остаток по ресурсу ""Сумма"" означает задолженность контрагента перед нами.
//
Функция ПросроченныеДолги(Дата, МинДолг, СрокДолга) Экспорт
	
	Если Дата = Неопределено Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	
	// Нормируем параметры дат
	ДатаКонец     = КонецДня(Дата);
	ДатаГраница   = НачалоДня(ДобавитьКДате(ДатаКонец, ВидИнтервала.День, -Макс(0, СрокДолга)));
	
	Запрос = Новый Запрос;
	
	ТекстЗапроса =
	""ВЫБРАТЬ
	|	ОстКон.Контрагент КАК Контрагент,
	|	ОстКон.СуммаОстаток КАК ДолгВсего,
	|	ВЫБОР
	|		КОГДА (ЕСТЬNULL(ОстНач.СуммаОстаток, 0) - ЕСТЬNULL(Обороты.СуммаРасход, 0)) > 0
	|			ТОГДА (ЕСТЬNULL(ОстНач.СуммаОстаток, 0) - ЕСТЬNULL(Обороты.СуммаРасход, 0))
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК ДолгПросроченный,
	|	ВЫБОР
	|		КОГДА (ЕСТЬNULL(ОстНач.СуммаОстаток, 0) - ЕСТЬNULL(Обороты.СуммаРасход, 0)) > 0
	|			ТОГДА &ДатаГраница
	|		ИНАЧЕ NULL
	|	КОНЕЦ КАК ДатаОбразованияДолга
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&ДатаКонец, Контрагент) КАК ОстКон
	|		ЛЕВОЕ СОЕДИНЕНИЕ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&ДатаГраница, Контрагент) КАК ОстНач
	|	ПО ОстНач.Контрагент = ОстКон.Контрагент
	|		ЛЕВОЕ СОЕДИНЕНИЕ
	|	РегистрНакопления.Взаиморасчеты.Обороты(&ДатаГраница, &ДатаКонец, Контрагент) КАК Обороты
	|	ПО Обороты.Контрагент = ОстКон.Контрагент
	|ГДЕ
	|	ОстКон.СуммаОстаток > &МинДолг
	|	И (ЕСТЬNULL(ОстНач.СуммаОстаток, 0) - ЕСТЬNULL(Обороты.СуммаРасход, 0)) > 0"";
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, ""|"", Символы.ПС);
	Запрос.УстановитьПараметр(""ДатаКонец"",   ДатаКонец);
	Запрос.УстановитьПараметр(""ДатаГраница"", ДатаГраница);
	Запрос.УстановитьПараметр(""МинДолг"",     МинДолг);
	
	Результат = Запрос.Выполнить();
	Возврат Результат.Выгрузить();
	
КонецФункции"
"создай функцию СоздатьИнтернетПочтовоеСообщение(Письмо, Отправитель)
Параметры:
 - Письмо - СправочникСсылка.ИсходящиеПисьма - элемент справочника, на основании которого
			следует оформить объект системы ИнтернетПочтовоеСообщение для дальнейшей
				отправки с помощью механизмов интернет почты.
- Отправитель - Строка – email отправителя почтового сообщения

Возвращаемое значение:
    Объект ИнтернетПочтовоеСообщение. Содержит почтовое сообщение, готовое к отправке.","{
  ""Catalogs"": [
    {
      ""id"": ""ИсходящиеПисьма"",
      ""name"": ""Исходящие письма"",
      ""Attributes"": [
        {
          ""id"": ""Дата"",
          ""name"": ""Дата"",
          ""types"": [
            {
              ""type"": ""Date""
            }
          ]
        },
        {
          ""id"": ""Получатель"",
          ""name"": ""Получатель"",
          ""types"": [
            {
              ""type"": ""String"",
              ""StringQualifiers"": ""0""
            }
          ]
        },
        {
          ""id"": ""Содержимое"",
          ""name"": ""Содержимое"",
          ""types"": []
        },
        {
          ""id"": ""Текст"",
          ""name"": ""Текст"",
          ""types"": [
            {
              ""type"": ""String"",
              ""StringQualifiers"": ""0""
            }
          ]
        },
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        }
      ],
      ""TabularSections"": [
        {
          ""id"": ""Получатели"",
          ""name"": ""Получатели"",
          ""Attributes"": [
            {
              ""id"": ""ЭлектроннаяПочта"",
              ""name"": ""Электронная почта"",
              ""types"": [
                {
                  ""type"": ""String"",
                  ""StringQualifiers"": ""1000""
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}","Функция ЗадачаРешена(Сообщение) Экспорт

	// Ожидаемые значения для проверки (схематично)
	ОжидаемыйОтправитель = ""noreply@mycompany.com""; // Email отправителя
	ОжидаемаяТема = ""Предлагаем телевизоры Sony К3456P со скидкой""; // Тема письма
	ОжидаемоеКоличествоПолучателей = 1; // Количество получателей
	ОжидаемыйПолучатель1 = ""givotnovodstvo@mail.ru""; // Email получателя
	ОжидаемыйТекст = ""Предлагаем приобрести телевизоры Sony К3456P со скидкой 30%""; // Текст сообщения

	// Проверяем, что результат является ИнтернетПочтовымСообщением
	Если ТипЗнч(Сообщение) <> Тип(""ИнтернетПочтовоеСообщение"") Тогда
		Возврат Ложь;
	КонецЕсли;

	Если ТипЗнч(Сообщение.Отправитель) <> Тип(""ИнтернетПочтовыйАдрес"") Тогда
		Возврат Ложь;
	КонецЕсли;

	Если Сообщение.Отправитель.Адрес <> ОжидаемыйОтправитель Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем тему письма
	Если Сообщение.Тема <> ОжидаемаяТема Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем количество получателей
	Если Сообщение.Получатели.Количество() <> ОжидаемоеКоличествоПолучателей Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем адреса получателей
	Если Сообщение.Получатели.Количество() >= 1 Тогда
		Если ТипЗнч(Сообщение.Получатели[0]) <> Тип(""ИнтернетПочтовыйАдрес"") Тогда
			Возврат Ложь;
		КонецЕсли;

		Если Сообщение.Получатели[0].Адрес <> ОжидаемыйПолучатель1 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;

	// Проверяем наличие текста
	Если Сообщение.Тексты.Количество() <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем содержимое текста
	ТекстСообщения = Сообщение.Тексты[0].Текст;
	Если СтрНайти(ТекстСообщения, ОжидаемыйТекст) = 0 Тогда
		Возврат Ложь;
	КонецЕсли;

	// Проверяем, что дата отправления не установлена
	Если ЗначениеЗаполнено(Сообщение.ДатаОтправления) Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Истина;       
 

КонецФункции
","Функция СоздатьИнтернетПочтовоеСообщение(Письмо, Отправитель) Экспорт

	// Создаем новое интернет-почтовое сообщение
	Сообщение = Новый ИнтернетПочтовоеСообщение;

	// Устанавливаем отправителя
	Сообщение.Отправитель = Отправитель;

	// Устанавливаем тему письма из наименования справочника
	Сообщение.Тема = Письмо.Наименование;

	// Добавляем получателей из табличной части
	Для Каждого СтрокаПолучателя Из Письмо.Получатели Цикл
		Если ЗначениеЗаполнено(СтрокаПолучателя.ЭлектроннаяПочта) Тогда
			Сообщение.Получатели.Добавить(СтрокаПолучателя.ЭлектроннаяПочта);
		КонецЕсли;
	КонецЦикла;

	// Если в реквизите Получатель также указан адрес, добавляем его
	Если ЗначениеЗаполнено(Письмо.Получатель) Тогда
		// Проверяем, не добавлен ли уже этот адрес из табличной части
		АдресУжеДобавлен = Ложь;
		Для Каждого Получатель Из Сообщение.Получатели Цикл
			Если Получатель.Адрес = Письмо.Получатель Тогда
				АдресУжеДобавлен = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если НЕ АдресУжеДобавлен Тогда
			Сообщение.Получатели.Добавить(Письмо.Получатель);
		КонецЕсли;
	КонецЕсли;

	// Устанавливаем текст сообщения
	Если ЗначениеЗаполнено(Письмо.Текст) Тогда
		ТекстСообщения = Сообщение.Тексты.Добавить(Письмо.Текст);
		ТекстСообщения.ТипТекста = ТипТекстаПочтовогоСообщения.ПростойТекст;
	КонецЕсли;

	// Обрабатываем вложения из хранилища значения (если есть)
	Если ЗначениеЗаполнено(Письмо.Содержимое) Тогда
		Попытка
			Вложения = Письмо.Содержимое.Получить();
			Если ТипЗнч(Вложения) = Тип(""Массив"") Тогда
				Для Каждого Вложение Из Вложения Цикл
				 // Предполагаем, что вложение имеет свойства ИмяФайла и Данные
					Если ТипЗнч(Вложение) = Тип(""Структура"") Тогда
						Если Вложение.Свойство(""ИмяФайла"") И Вложение.Свойство(""Данные"") Тогда
						   Вл = Сообщение.Вложения.Добавить(Вложение.Данные, Вложение.ИмяФайла);
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		Исключение
		// Если не удалось обработать вложения, просто пропускаем
		КонецПопытки;
	КонецЕсли;

	Возврат Сообщение;

КонецФункции
","Функция ЗапуститьРешение() Экспорт

	// Подготовка тестовых данных
	Письмо = Справочники.ИсходящиеПисьма.НайтиПоНаименованию(""Предлагаем телевизоры Sony К3456P со скидкой"");

	// Вызываем функцию решения
	Отправитель = ""noreply@mycompany.com"";
	Сообщение = СоздатьИнтернетПочтовоеСообщение(Письмо.Ссылка, Отправитель);

	// Вызываем функцию валидатора для проверки решения задачи
	РезультатПроверки = ЗадачаРешена(Сообщение);

	Возврат РезультатПроверки;

КонецФункции","// ОбщийМодуль.ПочтовыеУтилитыСервера (сервер, экспорт)
// Функция создает и заполняет ИнтернетПочтовоеСообщение на основании элемента справочника ""Исходящие письма"".
//
// Параметры:
//  - Письмо       - СправочникСсылка.ИсходящиеПисьма
//  - Отправитель  - Строка (email отправителя)
//
// Возвращаемое значение:
//  - ИнтернетПочтовоеСообщение
//
Функция СоздатьИнтернетПочтовоеСообщение(Письмо, Отправитель) Экспорт
	
	// Базовые проверки
	Если Письмо = Неопределено Или Не ЗначениеЗаполнено(Письмо) Тогда
		ВызватьИсключение ""Не передана ссылка на исходящее письмо."";
	КонецЕсли;
	
	Если ПустаяСтрока(Отправитель) Тогда
		ВызватьИсключение ""Не указан отправитель."";
	КонецЕсли;
	
	Если Не EmailКорректен(Отправитель) Тогда
		ВызватьИсключение ""Указан некорректный email отправителя: "" + Отправитель;
	КонецЕсли;
	
	// Получаем объект для доступа к табличным частям
	ОбъектПисьма = Письмо.ПолучитьОбъект();
	
	// Создаем сообщение
	Сообщение = Новый ИнтернетПочтовоеСообщение;
	Сообщение.Отправитель = Отправитель;
	
	// Сбор адресатов из реквизита и табличной части
	УникАдресаты = Новый Множество;
	
	// Реквизит ""Получатель"" (строка, может содержать несколько через ; или ,)
	Если ЗначениеЗаполнено(ОбъектПисьма.Получатель) Тогда
		Для каждого Эл Из НормализоватьСписокАдресов(Строка(ОбъектПисьма.Получатель)) Цикл
			УникАдресаты.Добавить(Эл);
		КонецЦикла;
	КонецЕсли;
	
	// ТЧ ""Получатели"" (каждая строка может содержать один или несколько адресов)
	Для каждого СтрПолучателя Из ОбъектПисьма.Получатели Цикл
		Если ЗначениеЗаполнено(СтрПолучателя.ЭлектроннаяПочта) Тогда
			Для каждого Эл Из НормализоватьСписокАдресов(Строка(СтрПолучателя.ЭлектроннаяПочта)) Цикл
				УникАдресаты.Добавить(Эл);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Если УникАдресаты.Количество() = 0 Тогда
		ВызватьИсключение ""Не указаны корректные адреса получателей."";
	КонецЕсли;
	
	// Заполняем получателей
	Для каждого Эл Из УникАдресаты Цикл
		Сообщение.Получатели.Добавить(Эл);
	КонецЦикла;
	
	// Текст письма: предпочитаем HTML, если он присутствует и распознан
	УстановленHTML = Ложь;
	
	Если ЗначениеЗаполнено(ОбъектПисьма.Содержимое) Тогда
		ТипСодержимого = ТипЗнч(ОбъектПисьма.Содержимое);
		Если ТипСодержимого = Тип(""Строка"") Тогда
			СтрСодержимого = Строка(ОбъектПисьма.Содержимое);
			Если ЭтоHTML(СтрСодержимого) Тогда
				Сообщение.ТекстПисьмаHTML = СтрСодержимого;
				УстановленHTML = Истина;
			Иначе
				Сообщение.ТекстПисьма = СтрСодержимого;
			КонецЕсли;
		ИначеЕсли ТипСодержимого = Тип(""HTMLДокумент"") Тогда
			Попытка
				Сообщение.ТекстПисьмаHTML = ОбъектПисьма.Содержимое.ПолучитьHTML();
				УстановленHTML = Истина;
			Исключение
				// Если получить HTML не удалось, не прерываем — fallback ниже
			КонецПопытки;
		Иначе
			// Неизвестный тип содержимого — игнорируем, fallback ниже
		КонецЕсли;
	КонецЕсли;
	
	Если Не УстановленHTML И ЗначениеЗаполнено(ОбъектПисьма.Текст) Тогда
		Сообщение.ТекстПисьма = Строка(ОбъектПисьма.Текст);
	КонецЕсли;
	
	// Здесь можно при необходимости задать тему (необязательно)
	// Пример:
	// Если ПустаяСтрока(Сообщение.Тема) Тогда
	// 	Сообщение.Тема = ""Исходящее письмо от "" + Формат(ОбъектПисьма.Дата, ""ДФ=dd.MM.yyyy HH:mm"");
	// КонецЕсли;
	
	Возврат Сообщение;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// Вспомогательные функции (локальные)

Функция НормализоватьСписокАдресов(АдресаСтрокой) Экспорт
	
	Результат = Новый Массив;
	Если ПустаяСтрока(АдресаСтрокой) Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Приводим все распространенные разделители к "";""
	СтрАдреса = Строка(АдресаСтрокой);
	СтрАдреса = СтрЗаменить(СтрАдреса, Символы.ПС, "";"");
	СтрАдреса = СтрЗаменить(СтрАдреса, Символы.ВК, "";"");
	СтрАдреса = СтрЗаменить(СтрАдреса, "","", "";"");
	// Избегаем множественных ;; 
	Пока Найти(СтрАдреса, "";;"") > 0 Цикл
		СтрАдреса = СтрЗаменить(СтрАдреса, "";;"", "";"");
	КонецЦикла;
	
	Уник = Новый Множество;
	Для каждого Кусок Из СтрРазделить(СтрАдреса, "";"") Цикл
		Адрес = СокрЛП(Кусок);
		Если ПустаяСтрока(Адрес) Тогда
			Продолжить;
		EndIf;
		
		// Извлекаем чистый e-mail из форм ""Имя <email@domain>"" или с кавычками
		Адрес = ИзвлечьEmailИзСтроки(Адрес);
		
		Если Не ПустаяСтрока(Адрес) И EmailКорректен(Адрес) Тогда
			// Приведем к нижнему регистру для дедупликации
			Нижний = НРег(Адрес);
			Если Не Уник.Содержит(Нижний) Тогда
				Уник.Добавить(Нижний);
				Результат.Добавить(Адрес);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции


Функция ИзвлечьEmailИзСтроки(СтрокаАдреса)
	Если ПустаяСтрока(СтрокаАдреса) Тогда
		Возврат """";
	КонецЕсли;
	
	С = СокрЛП(Строка(СтрокаАдреса));
	
	// Убираем окружающие кавычки
	Если Лев(С, 1) = """""""" И Прав(С, 1) = """""""" Тогда
		С = Сред(С, 2, СтрДлина(С) - 2);
	КонецЕсли;
	
	ПозОткр = Найти(С, ""<"");
	ПозЗакр = Найти(С, "">"");
	Если ПозОткр > 0 И ПозЗакр > ПозОткр Тогда
		Возврат СокрЛП(Сред(С, ПозОткр + 1, ПозЗакр - ПозОткр - 1));
	КонецЕсли;
	
	// Если нет угловых скобок, пробуем найти ""word@word""
	Если Найти(С, ""@"") > 1 Тогда
		// Убираем лишние пробелы вокруг
		С = СокрЛП(С);
		// Если присутствуют пробелы, берем самый похожий токен
		Если Найти(С, "" "") > 0 Тогда
			Для каждого Токен Из СтрРазделить(С, "" "") Цикл
				Токен = СокрЛП(Токен);
				Если Найти(Токен, ""@"") > 1 Тогда
					Возврат Токен;
				КонецЕсли;
			КонецЦикла;
			Возврат """";
		Иначе
			Возврат С;
		КонецЕсли;
	КонецЕсли;
	
	Возврат """";
КонецФункции


Функция EmailКорректен(EmailСтрока)
	Если ПустаяСтрока(EmailСтрока) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Емейл = СокрЛП(Строка(EmailСтрока));
	
	// Простая быстрая валидация (без RegExp, достаточно для большинства случаев)
	Если Найти(Емейл, "" "") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПозСобака = Найти(Емейл, ""@"");
	Если ПозСобака <= 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Домен = Сред(Емейл, ПозСобака + 1);
	Если ПустаяСтрока(Домен) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПозТочкаВДомене = Найти(Домен, ""."");
	Если ПозТочкаВДомене <= 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Минимальная длина TLD
	Если СтрДлина(Сред(Домен, ПозТочкаВДомене + 1)) < 2 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции


Функция ЭтоHTML(Текст)
	Если ПустаяСтрока(Текст) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Ниж = НРег(Текст);
	// Простейшие эвристики
	Если Найти(Ниж, ""<html"") > 0 Или Найти(Ниж, ""<body"") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	Если Найти(Ниж, ""<p>"") > 0 Или Найти(Ниж, ""<br"") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции"
