task,context,task_id,env,output
"Создай функцию ЗаполнитьТабличнуюЧастьОстатками(ДокументОбъект), которая заполняет табличную часть документа «Заказ» «Товары» остатками из регистра «ТоварныеЗапасы» для склада и даты, заданных в документе. Отбирать только товары видом товара = Товар. Для каждой позиции остатка нужно добавить строку в табличную часть и перенести туда товар и количество.","{
  ""Documents"": [
    {
      ""id"": ""Заказ"",
      ""properties"": [
        ""Номер"": ""string"",
        ""Дата"": ""date"",
        ""Клиент"": ""Ref.Контрагенты"",
        ""Склад"": ""Ref.Склады"",
      ],
      ""tabularSections"": [
        {
          ""Товары"": [
            ""Товар"": ""Ref.Товары"",
            ""Количество"": ""number"",
            ""Цена"": ""number"",
            ""Сумма"": ""number""
          ]
        }
      ]
    }
  ]
}",task_001,server,"Функция ЗаполнитьТабличнуюЧастьОстатками(ДокументОбъект) Экспорт
	
	// Очищаем табличную часть перед заполнением
	ДокументОбъект.Товары.Очистить();
	
	// Проверяем, что заполнены необходимые реквизиты
	Если НЕ ЗначениеЗаполнено(ДокументОбъект.Склад) Тогда
		Сообщить(""Не заполнен склад в документе!"");
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ДокументОбъект.Дата) Тогда
		Сообщить(""Не заполнена дата в документе!"");
		Возврат Ложь;
	КонецЕсли;
	
	// Создаем запрос для получения остатков
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ТоварныеЗапасыОстатки.Товар КАК Товар,
	|	ТоварныеЗапасыОстатки.КоличествоОстаток КАК Количество
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(
	|		&Дата,
	|		Склад = &Склад
	|		И Товар.ВидТовара = ЗНАЧЕНИЕ(Перечисление.ВидыТоваров.Товар)) КАК ТоварныеЗапасыОстатки
	|ГДЕ
	|	ТоварныеЗапасыОстатки.КоличествоОстаток > 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	Товар"";
	
	Запрос.УстановитьПараметр(""Дата"", ДокументОбъект.Дата);
	Запрос.УстановитьПараметр(""Склад"", ДокументОбъект.Склад);
	
	// Выполняем запрос
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		Сообщить(""Нет остатков товаров на складе на указанную дату!"");
		Возврат Ложь;
	КонецЕсли;
	
	// Заполняем табличную часть
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		НоваяСтрока = ДокументОбъект.Товары.Добавить();
		НоваяСтрока.Товар = Выборка.Товар;
		НоваяСтрока.Количество = Выборка.Количество;
		// Цена и Сумма могут быть заполнены отдельно или через обработчики
	КонецЦикла;
	
	Сообщить(""Табличная часть заполнена. Добавлено строк: "" + ДокументОбъект.Товары.Количество());
	
	Возврат Истина;
	
КонецФункции"
"Создай функцию ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата) которая выводит в табличный документ задолженность по контрагентам из регистра Взаиморасчеты на дату. В макете есть секции Шапка и Строка, в секции строка есть параметры “Контрагент” и “Задолженность”","{
  ""AccumulationRegisters"": [
    {
      ""id"": ""Взаиморасчеты"",
      ""name"": ""Взаиморасчеты"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        },
        {
          ""id"": ""Валюта"",
          ""name"": ""Валюта"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Валюты""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Сумма"",
          ""name"": ""Сумма"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_002,server,"Процедура ЗаполнитьТабличныйДокумент(ТабДокумент, Макет, Дата) Экспорт
	
	// Очищаем табличный документ
	ТабДокумент.Очистить();
	
	// Выводим шапку
	ОбластьШапка = Макет.ПолучитьОбласть(""Шапка"");
	ТабДокумент.Вывести(ОбластьШапка);
	
	// Получаем остатки по регистру на указанную дату
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ВзаиморасчетыОстатки.Контрагент КАК Контрагент,
	|	СУММА(ВзаиморасчетыОстатки.СуммаОстаток) КАК Задолженность
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&Дата, ) КАК ВзаиморасчетыОстатки
	|
	|СГРУППИРОВАТЬ ПО
	|	ВзаиморасчетыОстатки.Контрагент
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВзаиморасчетыОстатки.СуммаОстаток) <> 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	Контрагент"";
	
	Запрос.УстановитьПараметр(""Дата"", Дата);
	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	
	// Получаем область строки из макета
	ОбластьСтрока = Макет.ПолучитьОбласть(""Строка"");
	
	// Заполняем табличный документ данными
	Пока Выборка.Следующий() Цикл
		
		// Заполняем параметры области
		ОбластьСтрока.Параметры.Контрагент = Выборка.Контрагент;
		ОбластьСтрока.Параметры.Задолженность = Выборка.Задолженность;
		
		// Выводим строку в табличный документ
		ТабДокумент.Вывести(ОбластьСтрока);
		
	КонецЦикла;
	
КонецПроцедуры"
Создай функцию УстановитьСклад(ДокументОбъект) которая устанавливает во всех строках ТЧ «Товары» значение поля «СкладСтроки» равным реквизиту документа «Склад».,"{
  ""AccumulationRegisters"": [
    {
      ""id"": ""Взаиморасчеты"",
      ""name"": ""Взаиморасчеты"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        },
        {
          ""id"": ""Валюта"",
          ""name"": ""Валюта"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Валюты""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Сумма"",
          ""name"": ""Сумма"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_003,server,"Процедура УстановитьСклад(ДокументОбъект) Экспорт
	
	// Получаем значение реквизита Склад из документа
	СкладДокумента = ДокументОбъект.Склад;
	
	// Проходим по всем строкам табличной части Товары
	Для Каждого СтрокаТЧ Из ДокументОбъект.Товары Цикл
		
		// Устанавливаем значение поля СкладСтроки равным реквизиту документа Склад
		СтрокаТЧ.СкладСтроки = СкладДокумента;
		
	КонецЦикла;
	
КонецПроцедуры"
Создай функцию УдалитьПоследнююЗапись(Валюта) которая удалять последнюю по времени запись регистра сведений КурсыВалют с измерением Валюта = Валюта,"{
  ""InformationRegisters"": [
    {
      ""id"": ""КурсыВалют"",
      ""name"": ""Курсы валют"",
      ""InformationRegisterPeriodicity"": ""Day"",
      ""WriteMode"": ""Independent"",
      ""Dimensions"": [
        {
          ""id"": ""Валюта"",
          ""name"": ""Валюта"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Валюты""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Курс"",
          ""name"": ""Курс"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_004,server,"Функция УдалитьПоследнююЗапись(Валюта) Экспорт
	
	// Создаем запрос для поиска последней записи по времени
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	КурсыВалют.Период КАК Период,
	|	КурсыВалют.Валюта КАК Валюта
	|ИЗ
	|	РегистрСведений.КурсыВалют КАК КурсыВалют
	|ГДЕ
	|	КурсыВалют.Валюта = &Валюта
	|
	|УПОРЯДОЧИТЬ ПО
	|	Период УБЫВ"";
	
	Запрос.УстановитьПараметр(""Валюта"", Валюта);
	
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		// Записей не найдено
		Возврат Ложь;
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Выборка.Следующий();
	
	// Создаем менеджер записи для удаления
	МенеджерЗаписи = РегистрыСведений.КурсыВалют.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Период = Выборка.Период;
	МенеджерЗаписи.Валюта = Выборка.Валюта;
	
	// Удаляем запись
	МенеджерЗаписи.Удалить();
	
	Возврат Истина;
	
КонецФункции"
Создай функцию НеУстановленыЦены(Поставщик) которая возвращает СписокЗначений с элементами справочника Товары у которых Поставщик = Поставщик и нет записи в регистре сведений ЦеныТоваров,"{
  ""InformationRegisters"": [
    {
      ""id"": ""ЦеныТоваров"",
      ""name"": ""Цены товаров"",
      ""InformationRegisterPeriodicity"": ""Day"",
      ""WriteMode"": ""Independent"",
      ""Dimensions"": [
        {
          ""id"": ""Товар"",
          ""name"": ""Товар"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Товары""
            }
          ]
        },
        {
          ""id"": ""ВидЦен"",
          ""name"": ""Вид цен"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.ВидыЦен""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Цена"",
          ""name"": ""Цена"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_005,server,"Функция НеУстановленыЦены(Поставщик) Экспорт
	
	СписокЗначений = Новый СписокЗначений;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	Товары.Ссылка КАК Товар
	|ИЗ
	|	Справочник.Товары КАК Товары
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЦеныТоваров КАК ЦеныТоваров
	|		ПО Товары.Ссылка = ЦеныТоваров.Товар
	|ГДЕ
	|	Товары.Поставщик = &Поставщик
	|	И ЦеныТоваров.Товар ЕСТЬ NULL
	|	И НЕ Товары.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	Товар"";
	
	Запрос.УстановитьПараметр(""Поставщик"", Поставщик);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		СписокЗначений.Добавить(Выборка.Товар);
	КонецЦикла;
	
	Возврат СписокЗначений;
	
КонецФункции"
"Создай функцию ВыгрузитьОстаткиСклада(Склад, МинимальныйОстаток, ФайлJson), которая получает остаки товаров склада на текущую дату из регистра ТоварныеЗапасы у которых остаток больше или равен значению МинимальныйОстаток. Записать файл в json формате как список с полями ""Товар_Код"", ""Товар_Наименование"", ""Остаток"" (число, округленное до целого). Строки списка должны быть упорядочены по возрастанию поля Товар_Код","{
  ""AccumulationRegisters"": [
    {
      ""id"": ""ТоварныеЗапасы"",
      ""name"": ""Товарные запасы"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Товар"",
          ""name"": ""Товар"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Товары""
            }
          ]
        },
        {
          ""id"": ""Склад"",
          ""name"": ""Склад"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Склады""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Количество"",
          ""name"": ""Количество"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_006,server,"Процедура ВыгрузитьОстаткиСклада(Склад, МинимальныйОстаток, ФайлJson) Экспорт
	
	// Создаем запрос для получения остатков
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ТоварныеЗапасыОстатки.Товар.Код КАК Товар_Код,
	|	ТоварныеЗапасыОстатки.Товар.Наименование КАК Товар_Наименование,
	|	ТоварныеЗапасыОстатки.КоличествоОстаток КАК Остаток
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(, Склад = &Склад) КАК ТоварныеЗапасыОстатки
	|ГДЕ
	|	ТоварныеЗапасыОстатки.КоличествоОстаток >= &МинимальныйОстаток
	|
	|УПОРЯДОЧИТЬ ПО
	|	Товар_Код"";
	
	Запрос.УстановитьПараметр(""Склад"", Склад);
	Запрос.УстановитьПараметр(""МинимальныйОстаток"", МинимальныйОстаток);
	
	// Выполняем запрос
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	// Формируем массив для JSON
	МассивДанных = Новый Массив;
	
	Пока Выборка.Следующий() Цикл
		СтрокаДанных = Новый Структура;
		СтрокаДанных.Вставить(""Товар_Код"", Выборка.Товар_Код);
		СтрокаДанных.Вставить(""Товар_Наименование"", Выборка.Товар_Наименование);
		СтрокаДанных.Вставить(""Остаток"", Окр(Выборка.Остаток, 0, РежимОкругления.Окр15как20));
		
		МассивДанных.Добавить(СтрокаДанных);
	КонецЦикла;
	
	// Записываем в JSON файл
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ОткрытьФайл(ФайлJson, , , Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, Символы.Таб));
	ЗаписатьJSON(ЗаписьJSON, МассивДанных);
	ЗаписьJSON.Закрыть();
	
КонецПроцедуры"
"создай функцию ВыбратьСтрокиТаблицы(Таблица, Склад, Наименование), которая получает на вход параметр типа ТаблицаЗначений
в которой есть колонки ""Склад"", ""Товар"" типа справочник Товары, ""Количество"". Нужно вернуть ТаблицуЗначений, в которую войдут только те строки из входной таблицы, 
у которых значение в колонке ""Склад"" равно параметру Склад, а значение в колонке ""Товар.Наименование"" содержит подстроку параметра ""Наименование"".",,task_007,server,"Функция ВыбратьСтрокиТаблицы(Таблица, Склад, Наименование) Экспорт
	
	// Создаем результирующую таблицу значений с той же структурой
	РезультатТаблица = Таблица.Скопировать(Новый Массив);
	
	// Проверяем входные параметры
	Если Таблица = Неопределено Или Таблица.Количество() = 0 Тогда
		Возврат РезультатТаблица;
	КонецЕсли;
	
	// Приводим наименование к верхнему регистру для поиска без учета регистра
	НаименованиеПоиск = ВРег(СокрЛП(Наименование));
	
	// Перебираем строки исходной таблицы
	Для Каждого СтрокаТаблицы Из Таблица Цикл
		
		// Проверяем условие по складу
		УсловиеСклад = Ложь;
		Если Склад = Неопределено Тогда
			УсловиеСклад = Истина;
		ИначеЕсли СтрокаТаблицы.Склад = Склад Тогда
			УсловиеСклад = Истина;
		КонецЕсли;
		
		// Проверяем условие по наименованию товара
		УсловиеНаименование = Ложь;
		Если ПустаяСтрока(Наименование) Тогда
			УсловиеНаименование = Истина;
		ИначеЕсли НЕ СтрокаТаблицы.Товар.Пустая() Тогда
			НаименованиеТовара = ВРег(СокрЛП(СтрокаТаблицы.Товар.Наименование));
			Если Найти(НаименованиеТовара, НаименованиеПоиск) > 0 Тогда
				УсловиеНаименование = Истина;
			КонецЕсли;
		КонецЕсли;
		
		// Если оба условия выполнены, добавляем строку в результат
		Если УсловиеСклад И УсловиеНаименование Тогда
			НоваяСтрока = РезультатТаблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат РезультатТаблица;
	
КонецФункции"
"Создай функцию УшедшийТовар(Дата1, Дата2), которая возвращает таблицу значений с товаром, который был на складе (любом) на Дата1, но отсутствует на складе на Дата2. 
Использовать остатки регистра ""ТоварныеЗапасы"".
В таблице должны быть колонки: ""Товар"" (ссылка на справочник Товары), ""Количество"" (количество товара на Дата1).","{
  ""AccumulationRegisters"": [
    {
      ""id"": ""ТоварныеЗапасы"",
      ""name"": ""Товарные запасы"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Товар"",
          ""name"": ""Товар"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Товары""
            }
          ]
        },
        {
          ""id"": ""Склад"",
          ""name"": ""Склад"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Склады""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Количество"",
          ""name"": ""Количество"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_008,server,"Функция УшедшийТовар(Дата1, Дата2) Экспорт
	
	// Создаем таблицу значений для результата
	ТаблицаРезультат = Новый ТаблицаЗначений;
	ТаблицаРезультат.Колонки.Добавить(""Товар"", Новый ОписаниеТипов(""СправочникСсылка.Товары""));
	ТаблицаРезультат.Колонки.Добавить(""Количество"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(10, 2)));
	
	// Создаем запрос для получения товаров, которые были на Дата1, но отсутствуют на Дата2
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ОстаткиНаДата1.Товар КАК Товар,
	|	СУММА(ОстаткиНаДата1.КоличествоОстаток) КАК Количество
	|ПОМЕСТИТЬ ОстаткиНаДату1
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(&Дата1, ) КАК ОстаткиНаДата1
	|ГДЕ
	|	ОстаткиНаДата1.КоличествоОстаток > 0
	|
	|СГРУППИРОВАТЬ ПО
	|	ОстаткиНаДата1.Товар
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ОстаткиНаДата2.Товар КАК Товар,
	|	СУММА(ОстаткиНаДата2.КоличествоОстаток) КАК Количество
	|ПОМЕСТИТЬ ОстаткиНаДату2
	|ИЗ
	|	РегистрНакопления.ТоварныеЗапасы.Остатки(&Дата2, ) КАК ОстаткиНаДата2
	|ГДЕ
	|	ОстаткиНаДата2.КоличествоОстаток > 0
	|
	|СГРУППИРОВАТЬ ПО
	|	ОстаткиНаДата2.Товар
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ОстаткиНаДату1.Товар КАК Товар,
	|	ОстаткиНаДату1.Количество КАК Количество
	|ИЗ
	|	ОстаткиНаДату1 КАК ОстаткиНаДату1
	|		ЛЕВОЕ СОЕДИНЕНИЕ ОстаткиНаДату2 КАК ОстаткиНаДату2
	|		ПО ОстаткиНаДату1.Товар = ОстаткиНаДату2.Товар
	|ГДЕ
	|	ОстаткиНаДату2.Товар ЕСТЬ NULL
	|
	|УПОРЯДОЧИТЬ ПО
	|	Товар"";
	
	Запрос.УстановитьПараметр(""Дата1"", Дата1);
	Запрос.УстановитьПараметр(""Дата2"", Дата2);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ТаблицаРезультат = РезультатЗапроса.Выгрузить();
	КонецЕсли;
	
	Возврат ТаблицаРезультат;
	
КонецФункции"
"создай функцию ПросроченныеДолги(Дата, МинДолг, СрокДолга), которая возвращает таблицу значений с контрагентами, 
у которых на заданную дату есть долг больше МинДолг, и этот долг, или его часть, образовался более СрокДолга дней назад. Задолженность смотреть в регистре накопления Взаиморасчеты.
В таблице должны быть колонки: Контрагент, ДолгВсего, ДолгПросроченный, ДатаОбразованияДолга.","{
  ""AccumulationRegisters"": [
    {
      ""id"": ""Взаиморасчеты"",
      ""name"": ""Взаиморасчеты"",
      ""RegisterType"": ""Balance"",
      ""Dimensions"": [
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        },
        {
          ""id"": ""Валюта"",
          ""name"": ""Валюта"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Валюты""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Сумма"",
          ""name"": ""Сумма"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_009,server,"Функция ПросроченныеДолги(Дата, МинДолг, СрокДолга) Экспорт
	
	// Создаем таблицу значений для результата
	ТаблицаРезультат = Новый ТаблицаЗначений;
	ТаблицаРезультат.Колонки.Добавить(""Контрагент"", Новый ОписаниеТипов(""СправочникСсылка.Контрагенты""));
	ТаблицаРезультат.Колонки.Добавить(""ДолгВсего"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(15, 2)));
	ТаблицаРезультат.Колонки.Добавить(""ДолгПросроченный"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(15, 2)));
	ТаблицаРезультат.Колонки.Добавить(""ДатаОбразованияДолга"", Новый ОписаниеТипов(""Дата""));
	
	// Вычисляем граничную дату для просроченной задолженности
	ДатаГраницыПросрочки = НачалоДня(Дата) - СрокДолга * 86400;
	
	// Запрос для получения остатков на заданную дату
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ВзаиморасчетыОстатки.Контрагент КАК Контрагент,
	|	ВзаиморасчетыОстатки.Валюта КАК Валюта,
	|	ВзаиморасчетыОстатки.СуммаОстаток КАК ДолгВсего
	|ПОМЕСТИТЬ ОстаткиНаДату
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&Дата, ) КАК ВзаиморасчетыОстатки
	|ГДЕ
	|	ВзаиморасчетыОстатки.СуммаОстаток > &МинДолг
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВзаиморасчетыОстатки.Контрагент КАК Контрагент,
	|	ВзаиморасчетыОстатки.Валюта КАК Валюта,
	|	ВзаиморасчетыОстатки.СуммаОстаток КАК ДолгПросроченный,
	|	МАКСИМУМ(Взаиморасчеты.Период) КАК ДатаОбразованияДолга
	|ПОМЕСТИТЬ ПросроченныеОстатки
	|ИЗ
	|	РегистрНакопления.Взаиморасчеты.Остатки(&ДатаГраницыПросрочки, ) КАК ВзаиморасчетыОстатки
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления.Взаиморасчеты КАК Взаиморасчеты
	|		ПО ВзаиморасчетыОстатки.Контрагент = Взаиморасчеты.Контрагент
	|			И ВзаиморасчетыОстатки.Валюта = Взаиморасчеты.Валюта
	|			И (Взаиморасчеты.Период <= &ДатаГраницыПросрочки)
	|			И (Взаиморасчеты.Сумма > 0)
	|ГДЕ
	|	ВзаиморасчетыОстатки.СуммаОстаток > 0
	|
	|СГРУППИРОВАТЬ ПО
	|	ВзаиморасчетыОстатки.Контрагент,
	|	ВзаиморасчетыОстатки.Валюта,
	|	ВзаиморасчетыОстатки.СуммаОстаток
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ОстаткиНаДату.Контрагент КАК Контрагент,
	|	СУММА(ОстаткиНаДату.ДолгВсего) КАК ДолгВсего,
	|	СУММА(ЕСТЬNULL(ПросроченныеОстатки.ДолгПросроченный, 0)) КАК ДолгПросроченный,
	|	МИНИМУМ(ПросроченныеОстатки.ДатаОбразованияДолга) КАК ДатаОбразованияДолга
	|ИЗ
	|	ОстаткиНаДату КАК ОстаткиНаДату
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПросроченныеОстатки КАК ПросроченныеОстатки
	|		ПО ОстаткиНаДату.Контрагент = ПросроченныеОстатки.Контрагент
	|			И ОстаткиНаДату.Валюта = ПросроченныеОстатки.Валюта
	|
	|СГРУППИРОВАТЬ ПО
	|	ОстаткиНаДату.Контрагент
	|
	|ИМЕЮЩИЕ
	|	СУММА(ЕСТЬNULL(ПросроченныеОстатки.ДолгПросроченный, 0)) > 0
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДолгПросроченный УБЫВ"";
	
	Запрос.УстановитьПараметр(""Дата"", КонецДня(Дата));
	Запрос.УстановитьПараметр(""МинДолг"", МинДолг);
	Запрос.УстановитьПараметр(""ДатаГраницыПросрочки"", КонецДня(ДатаГраницыПросрочки));
	
	Результат = Запрос.Выполнить();
	
	Если НЕ Результат.Пустой() Тогда
		ТаблицаРезультат = Результат.Выгрузить();
	КонецЕсли;
	
	Возврат ТаблицаРезультат;
	
КонецФункции"
"создай функцию СоздатьИнтернетПочтовоеСообщение(Письмо, Отправитель)
Параметры:
 - Письмо - СправочникСсылка.ИсходящиеПисьма - элемент справочника, на основании которого
			следует оформить объект системы ИнтернетПочтовоеСообщение для дальнейшей
				отправки с помощью механизмов интернет почты.
- Отправитель - Строка – email отправителя почтового сообщения

Возвращаемое значение:
    Объект ИнтернетПочтовоеСообщение. Содержит почтовое сообщение, готовое к отправке.","{
  ""Catalogs"": [
    {
      ""id"": ""ИсходящиеПисьма"",
      ""name"": ""Исходящие письма"",
      ""Attributes"": [
        {
          ""id"": ""Дата"",
          ""name"": ""Дата"",
          ""types"": [
            {
              ""type"": ""Date""
            }
          ]
        },
        {
          ""id"": ""Получатель"",
          ""name"": ""Получатель"",
          ""types"": [
            {
              ""type"": ""String"",
              ""StringQualifiers"": ""0""
            }
          ]
        },
        {
          ""id"": ""Содержимое"",
          ""name"": ""Содержимое"",
          ""types"": []
        },
        {
          ""id"": ""Текст"",
          ""name"": ""Текст"",
          ""types"": [
            {
              ""type"": ""String"",
              ""StringQualifiers"": ""0""
            }
          ]
        },
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        }
      ],
      ""TabularSections"": [
        {
          ""id"": ""Получатели"",
          ""name"": ""Получатели"",
          ""Attributes"": [
            {
              ""id"": ""ЭлектроннаяПочта"",
              ""name"": ""Электронная почта"",
              ""types"": [
                {
                  ""type"": ""String"",
                  ""StringQualifiers"": ""1000""
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}",task_010,server,"Функция СоздатьИнтернетПочтовоеСообщение(Письмо, Отправитель) Экспорт
	
	// Создаем новое почтовое сообщение
	ПочтовоеСообщение = Новый ИнтернетПочтовоеСообщение;
	
	// Устанавливаем отправителя
	ПочтовоеСообщение.Отправитель = Новый ИнтернетПочтовыйАдрес(Отправитель);
	
	// Устанавливаем тему письма (используем наименование элемента справочника)
	ПочтовоеСообщение.Тема = Строка(Письмо);
	
	// Получаем данные письма
	ДанныеПисьма = ПолучитьДанныеПисьма(Письмо);
	
	// Устанавливаем текст письма
	Если ЗначениеЗаполнено(ДанныеПисьма.Текст) Тогда
		ПочтовоеСообщение.Тексты.Добавить(ДанныеПисьма.Текст, ТипТекстаПочтовогоСообщения.ПростойТекст);
	КонецЕсли;
	
	// Добавляем получателей из табличной части
	Для Каждого СтрокаПолучатель Из ДанныеПисьма.Получатели Цикл
		Если ЗначениеЗаполнено(СтрокаПолучатель.ЭлектроннаяПочта) Тогда
			АдресПолучателя = Новый ИнтернетПочтовыйАдрес(СтрокаПолучатель.ЭлектроннаяПочта);
			ПочтовоеСообщение.Получатели.Добавить(АдресПолучателя);
		КонецЕсли;
	КонецЦикла;
	
	// Если в табличной части нет получателей, используем реквизит Получатель
	Если ПочтовоеСообщение.Получатели.Количество() = 0 
		И ЗначениеЗаполнено(ДанныеПисьма.Получатель) Тогда
		АдресПолучателя = Новый ИнтернетПочтовыйАдрес(ДанныеПисьма.Получатель);
		ПочтовоеСообщение.Получатели.Добавить(АдресПолучателя);
	КонецЕсли;
	
	// Обрабатываем вложения из хранилища значений (реквизит Содержимое)
	Если ЗначениеЗаполнено(ДанныеПисьма.Содержимое) Тогда
		Попытка
			ДанныеСодержимого = ДанныеПисьма.Содержимое.Получить();
			Если ТипЗнч(ДанныеСодержимого) = Тип(""ДвоичныеДанные"") Тогда
				// Добавляем вложение
				Вложение = ПочтовоеСообщение.Вложения.Добавить(ДанныеСодержимого, ""Вложение.bin"");
			ИначеЕсли ТипЗнч(ДанныеСодержимого) = Тип(""Структура"") 
				ИЛИ ТипЗнч(ДанныеСодержимого) = Тип(""Соответствие"") Тогда
				// Если содержимое - коллекция файлов
				Для Каждого ЭлементВложения Из ДанныеСодержимого Цикл
					Если ТипЗнч(ЭлементВложения.Значение) = Тип(""ДвоичныеДанные"") Тогда
						ПочтовоеСообщение.Вложения.Добавить(ЭлементВложения.Значение, ЭлементВложения.Ключ);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		Исключение
			// Игнорируем ошибки при обработке вложений
		КонецПопытки;
	КонецЕсли;
	
	Возврат ПочтовоеСообщение;
	
КонецФункции

Функция ПолучитьДанныеПисьма(Письмо)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ИсходящиеПисьма.Получатель КАК Получатель,
	|	ИсходящиеПисьма.Текст КАК Текст,
	|	ИсходящиеПисьма.Содержимое КАК Содержимое
	|ИЗ
	|	Справочник.ИсходящиеПисьма КАК ИсходящиеПисьма
	|ГДЕ
	|	ИсходящиеПисьма.Ссылка = &Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ИсходящиеПисьмаПолучатели.ЭлектроннаяПочта КАК ЭлектроннаяПочта
	|ИЗ
	|	Справочник.ИсходящиеПисьма.Получатели КАК ИсходящиеПисьмаПолучатели
	|ГДЕ
	|	ИсходящиеПисьмаПолучатели.Ссылка = &Ссылка"";
	
	Запрос.УстановитьПараметр(""Ссылка"", Письмо);
	
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Результат = Новый Структура;
	Результат.Вставить(""Получатель"", """");
	Результат.Вставить(""Текст"", """");
	Результат.Вставить(""Содержимое"", Неопределено);
	Результат.Вставить(""Получатели"", Новый Массив);
	
	// Получаем основные данные
	ВыборкаОсновныхДанных = РезультатыЗапроса[0].Выбрать();
	Если ВыборкаОсновныхДанных.Следующий() Тогда
		Результат.Получатель = ВыборкаОсновныхДанных.Получатель;
		Результат.Текст = ВыборкаОсновныхДанных.Текст;
		Результат.Содержимое = ВыборкаОсновныхДанных.Содержимое;
	КонецЕсли;
	
	// Получаем получателей из табличной части
	ВыборкаПолучателей = РезультатыЗапроса[1].Выбрать();
	Пока ВыборкаПолучателей.Следующий() Цикл
		СтруктураПолучателя = Новый Структура(""ЭлектроннаяПочта"", ВыборкаПолучателей.ЭлектроннаяПочта);
		Результат.Получатели.Добавить(СтруктураПолучателя);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции"
"Создай функцию СоздатьДвиженияРегистраПродажи(ДокументСсылка), которая удаляет текущие движения документа и записывает новые движения регистра накопления «Продажи» 
по табличной части «Товары» документа ""РасходТовара""","{
  ""Catalogs"": [
    {
      ""id"": ""ИсходящиеПисьма"",
      ""name"": ""Исходящие письма"",
      ""Attributes"": [
        {
          ""id"": ""Дата"",
          ""name"": ""Дата"",
          ""types"": [
            {
              ""type"": ""Date""
            }
          ]
        },
        {
          ""id"": ""Получатель"",
          ""name"": ""Получатель"",
          ""types"": [
            {
              ""type"": ""String"",
              ""StringQualifiers"": ""0""
            }
          ]
        },
        {
          ""id"": ""Содержимое"",
          ""name"": ""Содержимое"",
          ""types"": []
        },
        {
          ""id"": ""Текст"",
          ""name"": ""Текст"",
          ""types"": [
            {
              ""type"": ""String"",
              ""StringQualifiers"": ""0""
            }
          ]
        },
        {
          ""id"": ""Контрагент"",
          ""name"": ""Контрагент"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Контрагенты""
            }
          ]
        }
      ],
      ""TabularSections"": [
        {
          ""id"": ""Получатели"",
          ""name"": ""Получатели"",
          ""Attributes"": [
            {
              ""id"": ""ЭлектроннаяПочта"",
              ""name"": ""Электронная почта"",
              ""types"": [
                {
                  ""type"": ""String"",
                  ""StringQualifiers"": ""1000""
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}",task_011,server,"Функция СоздатьДвиженияРегистраПродажи(ДокументСсылка) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ДокументСсылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Начинаем транзакцию для обеспечения целостности данных
	НачатьТранзакцию();
	
	Попытка
		
		// Получаем объект документа для работы с движениями
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		
		Если ДокументОбъект = Неопределено Тогда
			ВызватьИсключение ""Не удалось получить объект документа"";
		КонецЕсли;
		
		// Удаляем существующие движения по регистру Продажи
		ДокументОбъект.Движения.Продажи.Очистить();
		
		// Формируем новые движения на основе табличной части Товары
		Для Каждого СтрокаТовара Из ДокументОбъект.Товары Цикл
			
			// Создаем новое движение
			Движение = ДокументОбъект.Движения.Продажи.Добавить();
			
			// Заполняем реквизиты движения
			Движение.ВидДвижения = ВидДвиженияНакопления.Расход;
			Движение.Период = ДокументОбъект.Дата;
			
			// Заполняем измерения (типовые поля для регистра продаж)
			Движение.Номенклатура = СтрокаТовара.Номенклатура;
			
			// Если есть дополнительные измерения
			Если ДокументОбъект.Свойство(""Контрагент"") Тогда
				Движение.Контрагент = ДокументОбъект.Контрагент;
			КонецЕсли;
			
			Если ДокументОбъект.Свойство(""Склад"") Тогда
				Движение.Склад = ДокументОбъект.Склад;
			КонецЕсли;
			
			// Заполняем ресурсы
			Движение.Количество = СтрокаТовара.Количество;
			
			Если СтрокаТовара.Свойство(""Сумма"") Тогда
				Движение.Сумма = СтрокаТовара.Сумма;
			КонецЕсли;
			
			Если СтрокаТовара.Свойство(""Цена"") Тогда
				Движение.Цена = СтрокаТовара.Цена;
			КонецЕсли;
			
		КонецЦикла;
		
		// Записываем движения
		ДокументОбъект.Движения.Продажи.Записать();
		
		ЗафиксироватьТранзакцию();
		
		Возврат Истина;
		
	Исключение
		
		ОтменитьТранзакцию();
		
		ТекстОшибки = ОписаниеОшибки();
		ЗаписьЖурналаРегистрации(
			""Создание движений регистра Продажи"",
			УровеньЖурналаРегистрации.Ошибка,
			,
			ДокументСсылка,
			ТекстОшибки
		);
		
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции"
"Создай функцию ЗаменитьНоменклатуру(НоменклатураИсточник, НоменклатураЗамены, ДатаС, ДатаПо), которая находит документы ""Заказ"" в заданном интервале и в табличной части ""Товары"" 
заменяет номенклатуру НоменклатураИсточник на НоменклатураЗамены, оставляяя все прочие реквизиты низменными. Если в документе была хоть одна замена, и джокумент был проведен, документ перепроводится. 
Если документ помечен на удаление, пропускаем его. ","{
  ""Documents"": [
    {
      ""id"": ""Заказ"",
      ""properties"": [
        ""Номер"": ""string"",
        ""Дата"": ""date"",
        ""Клиент"": ""Ref.Контрагенты"",
        ""Склад"": ""Ref.Склады"",
      ],
      ""tabularSections"": [
        {
          ""Товары"": [
            ""Товар"": ""Ref.Товары"",
            ""Количество"": ""number"",
            ""Цена"": ""number"",
            ""Сумма"": ""number""
          ]
        }
      ]
    }
  ]
}",task_012,server,"Функция ЗаменитьНоменклатуру(НоменклатураИсточник, НоменклатураЗамены, ДатаС, ДатаПо) Экспорт
	
	// Проверка входных параметров
	Если НоменклатураИсточник = НоменклатураЗамены Тогда
		Возврат Новый Структура(""Успех, КоличествоДокументов, КоличествоСтрок"", Истина, 0, 0);
	КонецЕсли;
	
	// Счетчики для результата
	КоличествоОбработанныхДокументов = 0;
	КоличествоЗамененныхСтрок = 0;
	
	// Запрос для поиска документов
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	Заказ.Ссылка КАК Ссылка,
	|	Заказ.Проведен КАК Проведен,
	|	Заказ.ПометкаУдаления КАК ПометкаУдаления
	|ИЗ
	|	Документ.Заказ КАК Заказ
	|ГДЕ
	|	Заказ.Дата МЕЖДУ &ДатаС И &ДатаПо
	|	И НЕ Заказ.ПометкаУдаления
	|	И ИСТИНА В
	|			(ВЫБРАТЬ ПЕРВЫЕ 1
	|				ИСТИНА
	|			ИЗ
	|				Документ.Заказ.Товары КАК ЗаказТовары
	|			ГДЕ
	|				ЗаказТовары.Ссылка = Заказ.Ссылка
	|				И ЗаказТовары.Товар = &НоменклатураИсточник)
	|
	|УПОРЯДОЧИТЬ ПО
	|	Заказ.Дата"";
	
	Запрос.УстановитьПараметр(""ДатаС"", НачалоДня(ДатаС));
	Запрос.УстановитьПараметр(""ДатаПо"", КонецДня(ДатаПо));
	Запрос.УстановитьПараметр(""НоменклатураИсточник"", НоменклатураИсточник);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	// Обработка найденных документов
	Пока Выборка.Следующий() Цикл
		
		Попытка
			
			// Открываем документ для изменения
			ДокументОбъект = Выборка.Ссылка.ПолучитьОбъект();
			
			// Проверяем, не заблокирован ли документ
			Если ДокументОбъект = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Флаг, была ли хоть одна замена
			БылаЗамена = Ложь;
			
			// Проходим по табличной части и заменяем номенклатуру
			Для Каждого СтрокаТЧ Из ДокументОбъект.Товары Цикл
				
				Если СтрокаТЧ.Товар = НоменклатураИсточник Тогда
					СтрокаТЧ.Товар = НоменклатураЗамены;
					БылаЗамена = Истина;
					КоличествоЗамененныхСтрок = КоличествоЗамененныхСтрок + 1;
				КонецЕсли;
				
			КонецЦикла;
			
			// Если были замены, записываем документ
			Если БылаЗамена Тогда
				
				// Если документ был проведен, перепроводим его
				Если Выборка.Проведен Тогда
					ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				Иначе
					ДокументОбъект.Записать();
				КонецЕсли;
				
				КоличествоОбработанныхДокументов = КоличествоОбработанныхДокументов + 1;
				
			КонецЕсли;
			
		Исключение
			
			// Логируем ошибку и продолжаем обработку
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗаписьЖурналаРегистрации(
				""ЗаменаНоменклатуры"",
				УровеньЖурналаРегистрации.Ошибка,
				Метаданные.Документы.Заказ,
				Выборка.Ссылка,
				""Ошибка при замене номенклатуры: "" + ТекстОшибки);
			
		КонецПопытки;
		
	КонецЦикла;
	
	// Возвращаем результат
	Результат = Новый Структура;
	Результат.Вставить(""Успех"", Истина);
	Результат.Вставить(""КоличествоДокументов"", КоличествоОбработанныхДокументов);
	Результат.Вставить(""КоличествоСтрок"", КоличествоЗамененныхСтрок);
	
	Возврат Результат;
	
КонецФункции"
"Создай функцию РасчетКомиссииМенеджера(ТаблицаКомиссий, Процент, ДатаС, ДатаПо), которая находит документы ""Заказ"" в заданном интервале и вычисляет комиссию менеджера исходя из сумм в табличной части Товары
1) Смотрим только проведенные заказы
2) Сумма заказа - это сумма всех строк по реквизиту Сумма
3) Комиссия менеджера - сумма всех заказов менеджера (реквизит Автор) в периоде, умноженная на Процент
Функция должна заполнить таблицу ТаблицаКомиссий, где должно быть три колонки: Менеджер (из реквизита Автор), СуммаЗаказов, Комиссия. Менеджер в таблице должен быть уникальным, один менеджер - одна строка ","{
  ""Documents"": [
    {
      ""id"": ""Заказ"",
      ""properties"": [
        ""Номер"": ""string"",
        ""Дата"": ""date"",
        ""Клиент"": ""Ref.Контрагенты"",
        ""Склад"": ""Ref.Склады"",
        ""Автор"": ""Ref.Пользователи"",
      ],
      ""tabularSections"": [
        {
          ""Товары"": [
            ""Товар"": ""Ref.Товары"",
            ""Количество"": ""number"",
            ""Цена"": ""number"",
            ""Сумма"": ""number""
          ]
        }
      ]
    }
  ]
}",task_013,server,"Функция РасчетКомиссииМенеджера(ТаблицаКомиссий, Процент, ДатаС, ДатаПо) Экспорт
	
	// Создаем таблицу комиссий, если она не передана
	Если ТаблицаКомиссий = Неопределено Тогда
		ТаблицаКомиссий = Новый ТаблицаЗначений;
		ТаблицаКомиссий.Колонки.Добавить(""Менеджер"");
		ТаблицаКомиссий.Колонки.Добавить(""СуммаЗаказов"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(15, 2)));
		ТаблицаКомиссий.Колонки.Добавить(""Комиссия"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(15, 2)));
	Иначе
		ТаблицаКомиссий.Очистить();
	КонецЕсли;
	
	// Формируем запрос для получения данных
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	Заказ.Автор КАК Менеджер,
	|	СУММА(ЗаказТовары.Сумма) КАК СуммаЗаказов
	|ИЗ
	|	Документ.Заказ КАК Заказ
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.Заказ.Товары КАК ЗаказТовары
	|		ПО Заказ.Ссылка = ЗаказТовары.Ссылка
	|ГДЕ
	|	Заказ.Проведен = ИСТИНА
	|	И Заказ.Дата МЕЖДУ &ДатаС И &ДатаПо
	|
	|СГРУППИРОВАТЬ ПО
	|	Заказ.Автор"";
	
	Запрос.УстановитьПараметр(""ДатаС"", ДатаС);
	Запрос.УстановитьПараметр(""ДатаПо"", ДатаПо);
	
	// Выполняем запрос
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		Возврат ТаблицаКомиссий;
	КонецЕсли;
	
	// Обрабатываем результат
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		НоваяСтрока = ТаблицаКомиссий.Добавить();
		НоваяСтрока.Менеджер = Выборка.Менеджер;
		НоваяСтрока.СуммаЗаказов = Выборка.СуммаЗаказов;
		НоваяСтрока.Комиссия = Выборка.СуммаЗаказов * Процент / 100;
		
	КонецЦикла;
	
	Возврат ТаблицаКомиссий;
	
КонецФункции"
"Создай функцию ПолучитьШиринуВысотуКартинкиИзФайлаJPEG(ИмяФайла), которая считывает jpeg файл и возвращает структуру с данными 
{ ""Высота"": <высота картинки в пикселах>, ""Ширина"": <ширина картинки в пикселах>} ",,task_014,server,"Функция ПолучитьШиринуВысотуКартинкиИзФайлаJPEG(ИмяФайла) Экспорт
	
	Результат = Новый Структура(""Ширина, Высота"", 0, 0);
	
	Попытка
		// Открываем файл для чтения в двоичном режиме
		Файл = Новый Файл(ИмяФайла);
		Если НЕ Файл.Существует() Тогда
			Возврат Результат;
		КонецЕсли;
		
		ЧтениеДанных = Новый ЧтениеДанных(ИмяФайла);
		ПотокВПамяти = ЧтениеДанных.ПолучитьПотокВПамяти();
		
		// Проверяем сигнатуру JPEG (FF D8)
		Буфер = ПотокВПамяти.Прочитать(2);
		Если Буфер.Размер() < 2 Тогда
			ЧтениеДанных.Закрыть();
			Возврат Результат;
		КонецЕсли;
		
		Байт1 = Буфер.ПолучитьБайт(0);
		Байт2 = Буфер.ПолучитьБайт(1);
		
		Если Байт1 <> 255 ИЛИ Байт2 <> 216 Тогда // FF D8
			ЧтениеДанных.Закрыть();
			Возврат Результат;
		КонецЕсли;
		
		// Читаем сегменты JPEG
		Пока Истина Цикл
			
			// Читаем маркер сегмента
			Буфер = ПотокВПамяти.Прочитать(2);
			Если Буфер.Размер() < 2 Тогда
				Прервать;
			КонецЕсли;
			
			Маркер1 = Буфер.ПолучитьБайт(0);
			Маркер2 = Буфер.ПолучитьБайт(1);
			
			Если Маркер1 <> 255 Тогда
				Прервать;
			КонецЕсли;
			
			// Пропускаем заполняющие байты FF
			Пока Маркер2 = 255 Цикл
				Буфер = ПотокВПамяти.Прочитать(1);
				Если Буфер.Размер() < 1 Тогда
					Прервать;
				КонецЕсли;
				Маркер2 = Буфер.ПолучитьБайт(0);
			КонецЦикла;
			
			// Проверяем, является ли это SOF маркером (Start Of Frame)
			// SOF0 (C0), SOF1 (C1), SOF2 (C2), SOF3 (C3), SOF5 (C5), SOF6 (C6), SOF7 (C7),
			// SOF9 (C9), SOF10 (CA), SOF11 (CB), SOF13 (CD), SOF14 (CE), SOF15 (CF)
			Если (Маркер2 >= 192 И Маркер2 <= 195) ИЛИ 
				(Маркер2 >= 197 И Маркер2 <= 199) ИЛИ
				(Маркер2 >= 201 И Маркер2 <= 203) ИЛИ
				(Маркер2 >= 205 И Маркер2 <= 207) Тогда
				
				// Читаем длину сегмента (2 байта)
				Буфер = ПотокВПамяти.Прочитать(2);
				Если Буфер.Размер() < 2 Тогда
					Прервать;
				КонецЕсли;
				
				// Пропускаем 1 байт (точность)
				ПотокВПамяти.Прочитать(1);
				
				// Читаем высоту (2 байта, big-endian)
				Буфер = ПотокВПамяти.Прочитать(2);
				Если Буфер.Размер() < 2 Тогда
					Прервать;
				КонецЕсли;
				Высота = Буфер.ПолучитьБайт(0) * 256 + Буфер.ПолучитьБайт(1);
				
				// Читаем ширину (2 байта, big-endian)
				Буфер = ПотокВПамяти.Прочитать(2);
				Если Буфер.Размер() < 2 Тогда
					Прервать;
				КонецЕсли;
				Ширина = Буфер.ПолучитьБайт(0) * 256 + Буфер.ПолучитьБайт(1);
				
				Результат.Ширина = Ширина;
				Результат.Высота = Высота;
				
				Прервать;
				
			ИначеЕсли Маркер2 = 217 ИЛИ Маркер2 = 218 Тогда // EOI (End Of Image) или SOS (Start Of Scan)
				Прервать;
				
			Иначе
				// Читаем длину сегмента и пропускаем его
				Буфер = ПотокВПамяти.Прочитать(2);
				Если Буфер.Размер() < 2 Тогда
					Прервать;
				КонецЕсли;
				
				Длина = Буфер.ПолучитьБайт(0) * 256 + Буфер.ПолучитьБайт(1);
				
				// Пропускаем данные сегмента (длина включает сами 2 байта длины)
				Если Длина > 2 Тогда
					ПотокВПамяти.Прочитать(Длина - 2);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЧтениеДанных.Закрыть();
		
	Исключение
		Результат.Ширина = 0;
		Результат.Высота = 0;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции"
"Создай функцию ИзвлечьПартииФИФО(ТаблицаПартий, Сумма), которая возвращает таблицу партий на заданную сумму.
1) ТаблицаПартий имеет колонки ""Партия"", ""Дата"" типа Дата+Время, ""Сумма"" типа Число(14, 2)      
2) Нужно вернуть таблицу с аналогичными колонками, в которой будет список партий, идущих во времени первыми, которые в сумме дают Сумма
3) Если сумма накопленныех партий превышают требуемую, сумму последней по времени партии нужно подогнать, чтобы общаяя сумма сошлась с требуемым значением",,task_015,server,"Функция ИзвлечьПартииФИФО(ТаблицаПартий, Сумма) Экспорт
	
	// Создаем результирующую таблицу
	РезультатТаблица = Новый ТаблицаЗначений;
	РезультатТаблица.Колонки.Добавить(""Партия"");
	РезультатТаблица.Колонки.Добавить(""Дата"", Новый ОписаниеТипов(""Дата""));
	РезультатТаблица.Колонки.Добавить(""Сумма"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(14, 2)));
	
	// Проверяем входные параметры
	Если ТаблицаПартий = Неопределено Или ТаблицаПартий.Количество() = 0 Тогда
		Возврат РезультатТаблица;
	КонецЕсли;
	
	Если Сумма <= 0 Тогда
		Возврат РезультатТаблица;
	КонецЕсли;
	
	// Сортируем исходную таблицу по дате (FIFO - First In First Out)
	ТаблицаПартий.Сортировать(""Дата Возр"");
	
	// Накапливаем партии
	НакопленнаяСумма = 0;
	ТребуемаяСумма = Сумма;
	
	Для Каждого СтрокаПартии Из ТаблицаПартий Цикл
		
		// Проверяем, сколько еще нужно набрать
		ОстатокСуммы = ТребуемаяСумма - НакопленнаяСумма;
		
		Если ОстатокСуммы <= 0 Тогда
			// Уже набрали нужную сумму
			Прервать;
		КонецЕсли;
		
		НоваяСтрока = РезультатТаблица.Добавить();
		НоваяСтрока.Партия = СтрокаПартии.Партия;
		НоваяСтрока.Дата = СтрокаПартии.Дата;
		
		// Определяем, какую сумму взять из текущей партии
		Если СтрокаПартии.Сумма <= ОстатокСуммы Тогда
			// Берем всю партию целиком
			НоваяСтрока.Сумма = СтрокаПартии.Сумма;
			НакопленнаяСумма = НакопленнаяСумма + СтрокаПартии.Сумма;
		Иначе
			// Берем только часть партии (подгоняем под требуемую сумму)
			НоваяСтрока.Сумма = ОстатокСуммы;
			НакопленнаяСумма = НакопленнаяСумма + ОстатокСуммы;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат РезультатТаблица;
	
КонецФункции"
"Создай функцию ДополнитьТаблицуЗначениямиИзВторой(Таблица1, Таблица2, КолонкаУникальности), которая добавляет в начало первой ТЗ значения из второй ТЗ с обеспечением уникальности значения в колонке КолонкаУникальности
1) колонки обеих ТЗ совпадают   
2) Значения в КолонкаУникальности заполнены в обеих таблицах
",,task_016,server,"Функция ДополнитьТаблицуЗначениямиИзВторой(Таблица1, Таблица2, КолонкаУникальности) Экспорт
	
	// Создаем временную таблицу для хранения уникальных значений из первой таблицы
	ТаблицаУникальныхЗначений = Новый ТаблицаЗначений;
	ТаблицаУникальныхЗначений.Колонки.Добавить(КолонкаУникальности);
	
	// Заполняем таблицу уникальных значений из Таблица1
	Для Каждого Строка Из Таблица1 Цикл
		НоваяСтрока = ТаблицаУникальныхЗначений.Добавить();
		НоваяСтрока[КолонкаУникальности] = Строка[КолонкаУникальности];
	КонецЦикла;
	
	// Создаем массив для строк, которые нужно добавить в начало
	МассивДобавляемыхСтрок = Новый Массив;
	
	// Проходим по второй таблице и отбираем строки с уникальными значениями
	Для Каждого Строка2 Из Таблица2 Цикл
		
		// Проверяем, есть ли такое значение в первой таблице
		ПараметрыОтбора = Новый Структура(КолонкаУникальности, Строка2[КолонкаУникальности]);
		НайденныеСтроки = Таблица1.НайтиСтроки(ПараметрыОтбора);
		
		// Если значение уникально (не найдено в первой таблице)
		Если НайденныеСтроки.Количество() = 0 Тогда
			МассивДобавляемыхСтрок.Добавить(Строка2);
		КонецЕсли;
		
	КонецЦикла;
	
	// Добавляем строки в начало первой таблицы (в обратном порядке)
	Для Индекс = МассивДобавляемыхСтрок.Количество() - 1 По 0 Цикл
		
		Строка2 = МассивДобавляемыхСтрок[Индекс];
		НоваяСтрока = Таблица1.Вставить(0);
		
		// Копируем все колонки
		Для Каждого Колонка Из Таблица1.Колонки Цикл
			НоваяСтрока[Колонка.Имя] = Строка2[Колонка.Имя];
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Таблица1;
	
КонецФункции"
"Создай функцию ОбъектВСтруктуру(ОбъектДанных) принимает на вход объект и возвращает структуру с данными полученными из этого объекта 
1) Если у объекта есть табличные части, реквизиты и значения каждой табличной части должны быть представлены как массив со структурами
2) Стандартные реквизиты (Код, Наименование, Дата, и т.д.) тоже должный быть в структуре ответа
3) Общий вид выходной структуры 
{ ""Реквизит1"": ЗначениеРеквизита1, 
...    
""РеквизитN"": ЗначениеРеквизитаN,
""ТабличныеЧасти"": [  
	{ 
		""ИмяТабличнойЧасти1"": [ 
			{
				""Реквизит1ТабличнойЧасти1"": ЗначениеРеквизита1ВСтроке1,     
				""Реквизит2ТабличнойЧасти1"": ЗначениеРеквизита2ВСтроке1,  
				...
			},
			{
				""Реквизит1ТабличнойЧасти1"": ЗначениеРеквизита1ВСтроке2,     
				""Реквизит2ТабличнойЧасти1"": ЗначениеРеквизита2ВСтроке2,  
				...
			},	
		]
	}
]
}",,task_017,server,"Функция ОбъектВСтруктуру(ОбъектДанных) Экспорт
	
	Если ОбъектДанных = Неопределено Тогда
		Возврат Новый Структура();
	КонецЕсли;
	
	Результат = Новый Структура();
	
	// Получаем метаданные объекта
	МетаданныеОбъекта = ОбъектДанных.Метаданные();
	
	// Обрабатываем стандартные реквизиты
	Для Каждого СтандартныйРеквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		ИмяРеквизита = СтандартныйРеквизит.Имя;
		
		Попытка
			ЗначениеРеквизита = ОбъектДанных[ИмяРеквизита];
			Результат.Вставить(ИмяРеквизита, ЗначениеРеквизита);
		Исключение
			// Если реквизит недоступен, пропускаем
		КонецПопытки;
		
	КонецЦикла;
	
	// Обрабатываем обычные реквизиты
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		ИмяРеквизита = Реквизит.Имя;
		
		Попытка
			ЗначениеРеквизита = ОбъектДанных[ИмяРеквизита];
			Результат.Вставить(ИмяРеквизита, ЗначениеРеквизита);
		Исключение
			// Если реквизит недоступен, пропускаем
		КонецПопытки;
		
	КонецЦикла;
	
	// Обрабатываем табличные части
	МассивТабличныхЧастей = Новый Массив();
	
	Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Имя;
		СтруктураТабличнойЧасти = Новый Структура();
		МассивСтрокТабличнойЧасти = Новый Массив();
		
		Попытка
			ТабличнаяЧастьОбъекта = ОбъектДанных[ИмяТабличнойЧасти];
			
			// Обрабатываем каждую строку табличной части
			Для Каждого СтрокаТабличнойЧасти Из ТабличнаяЧастьОбъекта Цикл
				
				СтруктураСтроки = Новый Структура();
				
				// Добавляем стандартные реквизиты табличной части
				Для Каждого СтандартныйРеквизит Из ТабличнаяЧасть.СтандартныеРеквизиты Цикл
					ИмяРеквизита = СтандартныйРеквизит.Имя;
					
					Попытка
						ЗначениеРеквизита = СтрокаТабличнойЧасти[ИмяРеквизита];
						СтруктураСтроки.Вставить(ИмяРеквизита, ЗначениеРеквизита);
					Исключение
						// Если реквизит недоступен, пропускаем
					КонецПопытки;
					
				КонецЦикла;
				
				// Добавляем обычные реквизиты табличной части
				Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
					ИмяРеквизита = Реквизит.Имя;
					
					Попытка
						ЗначениеРеквизита = СтрокаТабличнойЧасти[ИмяРеквизита];
						СтруктураСтроки.Вставить(ИмяРеквизита, ЗначениеРеквизита);
					Исключение
						// Если реквизит недоступен, пропускаем
					КонецПопытки;
					
				КонецЦикла;
				
				МассивСтрокТабличнойЧасти.Добавить(СтруктураСтроки);
				
			КонецЦикла;
			
			СтруктураТабличнойЧасти.Вставить(ИмяТабличнойЧасти, МассивСтрокТабличнойЧасти);
			МассивТабличныхЧастей.Добавить(СтруктураТабличнойЧасти);
			
		Исключение
			// Если табличная часть недоступна, пропускаем
		КонецПопытки;
		
	КонецЦикла;
	
	// Добавляем табличные части в результат, если они есть
	Если МассивТабличныхЧастей.Количество() > 0 Тогда
		Результат.Вставить(""ТабличныеЧасти"", МассивТабличныхЧастей);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции"
"Создай функцию СкачкиЦен(Процент) Которая возвращает таблицу значений с колонками Товар, ЦенаБыла, ЦенаСтала, ДатаИзменения. 
В таблицу помещаются все ситуации, когда рост цен от одной записи к другой по одному товару больше чем Процент. Использовать запрос","{
  ""InformationRegisters"": [
    {
      ""id"": ""ЦеныТоваров"",
      ""name"": ""Цены товаров"",
      ""InformationRegisterPeriodicity"": ""Day"",
      ""WriteMode"": ""Independent"",
      ""Dimensions"": [
        {
          ""id"": ""Товар"",
          ""name"": ""Товар"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Товары""
            }
          ]
        },
        {
          ""id"": ""ВидЦен"",
          ""name"": ""Вид цен"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.ВидыЦен""
            }
          ]
        }
      ],
      ""Resources"": [
        {
          ""id"": ""Цена"",
          ""name"": ""Цена"",
          ""types"": [
            {
              ""type"": ""Number"",
              ""NumberQualifiers"": ""10.2""
            }
          ]
        }
      ]
    }
  ]
}",task_018,server,"Функция СкачкиЦен(Процент) Экспорт
	
	// Создаем таблицу значений для результата
	ТаблицаРезультат = Новый ТаблицаЗначений;
	ТаблицаРезультат.Колонки.Добавить(""Товар"");
	ТаблицаРезультат.Колонки.Добавить(""ЦенаБыла"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(10, 2)));
	ТаблицаРезультат.Колонки.Добавить(""ЦенаСтала"", Новый ОписаниеТипов(""Число"", Новый КвалификаторыЧисла(10, 2)));
	ТаблицаРезультат.Колонки.Добавить(""ДатаИзменения"", Новый ОписаниеТипов(""Дата""));
	
	// Формируем запрос для поиска скачков цен
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ЦеныТоваров.Товар КАК Товар,
	|	ЦеныТоваров.ВидЦен КАК ВидЦен,
	|	ЦеныТоваров.Период КАК Период,
	|	ЦеныТоваров.Цена КАК Цена
	|ПОМЕСТИТЬ ВТ_ВсеЦены
	|ИЗ
	|	РегистрСведений.ЦеныТоваров КАК ЦеныТоваров
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Товар,
	|	ВидЦен,
	|	Период
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТекущиеЦены.Товар КАК Товар,
	|	ТекущиеЦены.ВидЦен КАК ВидЦен,
	|	ТекущиеЦены.Период КАК ТекущийПериод,
	|	ТекущиеЦены.Цена КАК ТекущаяЦена,
	|	МАКСИМУМ(ПредыдущиеЦены.Период) КАК ПредыдущийПериод
	|ПОМЕСТИТЬ ВТ_ПарыЦен
	|ИЗ
	|	ВТ_ВсеЦены КАК ТекущиеЦены
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ВсеЦены КАК ПредыдущиеЦены
	|		ПО ТекущиеЦены.Товар = ПредыдущиеЦены.Товар
	|			И ТекущиеЦены.ВидЦен = ПредыдущиеЦены.ВидЦен
	|			И ТекущиеЦены.Период > ПредыдущиеЦены.Период
	|
	|СГРУППИРОВАТЬ ПО
	|	ТекущиеЦены.Товар,
	|	ТекущиеЦены.ВидЦен,
	|	ТекущиеЦены.Период,
	|	ТекущиеЦены.Цена
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Товар,
	|	ВидЦен,
	|	ПредыдущийПериод
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПарыЦен.Товар КАК Товар,
	|	ПредыдущиеЦены.Цена КАК ЦенаБыла,
	|	ПарыЦен.ТекущаяЦена КАК ЦенаСтала,
	|	ПарыЦен.ТекущийПериод КАК ДатаИзменения
	|ИЗ
	|	ВТ_ПарыЦен КАК ПарыЦен
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ВсеЦены КАК ПредыдущиеЦены
	|		ПО ПарыЦен.Товар = ПредыдущиеЦены.Товар
	|			И ПарыЦен.ВидЦен = ПредыдущиеЦены.ВидЦен
	|			И ПарыЦен.ПредыдущийПериод = ПредыдущиеЦены.Период
	|ГДЕ
	|	ПредыдущиеЦены.Цена <> 0
	|	И (ПарыЦен.ТекущаяЦена - ПредыдущиеЦены.Цена) / ПредыдущиеЦены.Цена * 100 > &Процент
	|
	|УПОРЯДОЧИТЬ ПО
	|	Товар,
	|	ДатаИзменения"";
	
	Запрос.УстановитьПараметр(""Процент"", Процент);
	
	// Выполняем запрос и получаем результат
	Результат = Запрос.Выполнить();
	
	Если НЕ Результат.Пустой() Тогда
		ТаблицаРезультат = Результат.Выгрузить();
	КонецЕсли;
	
	Возврат ТаблицаРезультат;
	
КонецФункции"
"Создай функцию ПересеченияРемонтов() которая возвращает пересечения периода ремонтов разных складов из регистра сведений ПериодыРемонтаСкладов
Возвращает таблицу значений с колонками Склад1, Склад2, НачалоПериода, КонецПериода. 
Где Склад1 и Склад2 - значения двух складов, периоды которых пересекаются, 
НачалоПериода и КонецПериода - начало и конец периодов пересечения.
Пример 
""Склад новый"" - ремонт с 12.08.2025 по 24.08.2025  
""Склад старый"" - ремонт с 22.08.2025 по 04.09.2025 

Результат: 
Склад1: ""Склад новый""
Склад2: ""Склад старый""   
НачалоПериода: 22.08.2025 
КонецПериода: 24.08.2025    

Результирующую таблицу отсортировать по возрастанию НачалоПериода                             

","{
  ""InformationRegisters"": [
    {
      ""id"": ""ПериодыРемонтаСкладов"",
      ""name"": ""Периоды ремонта складов"",
      ""InformationRegisterPeriodicity"": null,
      ""WriteMode"": ""Independent"",
      ""Dimensions"": [
        {
          ""id"": ""Склад"",
          ""name"": ""Склад"",
          ""types"": [
            {
              ""type"": ""Ref"",
              ""id"": ""Справочник.Склады""
            }
          ]
        },
        {
          ""id"": ""Начало"",
          ""name"": ""Начало"",
          ""types"": [
            {
              ""type"": ""Date""
            }
          ]
        },
        {
          ""id"": ""Окончание"",
          ""name"": ""Окончание"",
          ""types"": [
            {
              ""type"": ""Date""
            }
          ]
        }

      ],
      ""Resources"": []
    }
  ]
}
 
",task_019,server,"Функция ПересеченияРемонтов() Экспорт
	
	// Создаем таблицу значений для результата
	ТаблицаРезультат = Новый ТаблицаЗначений;
	ТаблицаРезультат.Колонки.Добавить(""Склад1"", Новый ОписаниеТипов(""СправочникСсылка.Склады""));
	ТаблицаРезультат.Колонки.Добавить(""Склад2"", Новый ОписаниеТипов(""СправочникСсылка.Склады""));
	ТаблицаРезультат.Колонки.Добавить(""НачалоПериода"", Новый ОписаниеТипов(""Дата""));
	ТаблицаРезультат.Колонки.Добавить(""КонецПериода"", Новый ОписаниеТипов(""Дата""));
	
	// Запрос для получения всех периодов ремонта
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	Периоды1.Склад КАК Склад1,
	|	Периоды1.Начало КАК Начало1,
	|	Периоды1.Окончание КАК Окончание1,
	|	Периоды2.Склад КАК Склад2,
	|	Периоды2.Начало КАК Начало2,
	|	Периоды2.Окончание КАК Окончание2
	|ИЗ
	|	РегистрСведений.ПериодыРемонтаСкладов КАК Периоды1
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ПериодыРемонтаСкладов КАК Периоды2
	|		ПО Периоды1.Склад < Периоды2.Склад
	|ГДЕ
	|	(Периоды1.Начало <= Периоды2.Окончание
	|			И Периоды1.Окончание >= Периоды2.Начало)"";
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	// Обрабатываем результаты и вычисляем пересечения
	Пока Выборка.Следующий() Цикл
		
		НоваяСтрока = ТаблицаРезультат.Добавить();
		НоваяСтрока.Склад1 = Выборка.Склад1;
		НоваяСтрока.Склад2 = Выборка.Склад2;
		
		// Начало пересечения - максимум из двух начал
		Если Выборка.Начало1 > Выборка.Начало2 Тогда
			НоваяСтрока.НачалоПериода = Выборка.Начало1;
		Иначе
			НоваяСтрока.НачалоПериода = Выборка.Начало2;
		КонецЕсли;
		
		// Конец пересечения - минимум из двух окончаний
		Если Выборка.Окончание1 < Выборка.Окончание2 Тогда
			НоваяСтрока.КонецПериода = Выборка.Окончание1;
		Иначе
			НоваяСтрока.КонецПериода = Выборка.Окончание2;
		КонецЕсли;
		
	КонецЦикла;
	
	// Сортируем результат по возрастанию НачалоПериода
	ТаблицаРезультат.Сортировать(""НачалоПериода"");
	
	Возврат ТаблицаРезультат;
	
КонецФункции"
"Создай функцию СформироватьОтчетПолучитьОстаток(Склад, Товар, Строка, Колонка) которая формирует отчет на сервере ""ОстаткиТоваровНаСкладах"" с отбором по складу и товару, 
и возвращает числовое значение из указанной ячейки табличного документа.  

Отчет ОстаткиТоваровНаСкладах сделан на СКД, основная схема которого имеет поля Склад и Товар для отбора.

Параметры функции:
- Склад - ссылка на элемент справочника Склады для отбора
- Товар - ссылка на элемент справочника Товары для отбора
- Строка - номер строки в табличном документе
- Колонка - номер колонки в табличном документе

Возвращаемое значение: целое число из указанной ячейки табличного документа.                           

",,task_020,server,"Функция СформироватьОтчетПолучитьОстаток(Склад, Товар, Строка, Колонка) Экспорт
	
	// Получаем объект отчета
	ОтчетОбъект = Отчеты.ОстаткиТоваровНаСкладах.Создать();
	
	// Получаем схему компоновки данных
	СхемаКомпоновкиДанных = Отчеты.ОстаткиТоваровНаСкладах.ПолучитьМакет(""ОсновнаяСхемаКомпоновкиДанных"");
	
	// Создаем настройки компоновки данных
	Настройки = СхемаКомпоновкиДанных.НастройкиПоУмолчанию;
	
	// Очищаем существующие отборы
	Настройки.Отбор.Элементы.Очистить();
	
	// Устанавливаем отбор по складу
	Если ЗначениеЗаполнено(Склад) Тогда
		ЭлементОтбора = Настройки.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(""Склад"");
		ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ЭлементОтбора.ПравоеЗначение = Склад;
		ЭлементОтбора.Использование = Истина;
	КонецЕсли;
	
	// Устанавливаем отбор по товару
	Если ЗначениеЗаполнено(Товар) Тогда
		ЭлементОтбора = Настройки.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(""Товар"");
		ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ЭлементОтбора.ПравоеЗначение = Товар;
		ЭлементОтбора.Использование = Истина;
	КонецЕсли;
	
	// Создаем компоновщик настроек
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	КомпоновщикНастроек.ЗагрузитьНастройки(Настройки);
	
	// Создаем табличный документ
	ТабличныйДокумент = Новый ТабличныйДокумент;
	
	// Создаем процессор компоновки данных
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(
		СхемаКомпоновкиДанных,
		КомпоновщикНастроек.ПолучитьНастройки(),
		,
		Истина
	);
	
	// Создаем процессор вывода
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(ТабличныйДокумент);
	
	// Выполняем компоновку
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	// Получаем значение из указанной ячейки
	Результат = 0;
	
	Попытка
		Область = ТабличныйДокумент.Область(Строка, Колонка, Строка, Колонка);
		ЗначениеЯчейки = Область.Текст;
		
		// Преобразуем текст в число
		Если ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
			Попытка
				Результат = Число(СтрЗаменить(ЗначениеЯчейки, "" "", """"));
			Исключение
				Результат = 0;
			КонецПопытки;
		КонецЕсли;
		
	Исключение
		Результат = 0;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции"
