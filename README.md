# 1C Code Bench

Система бенчмаркинга для тестирования и оценки производительности кода 1С:Предприятие.

## Обзор

1C Code Bench — это комплексный инструмент для бенчмаркинга, предназначенный для тестирования и измерения производительности фрагментов кода 1С:Предприятие. Система автоматизирует процесс загрузки кода в базу данных 1С, его выполнения и сбора метрик производительности.

## Возможности

- **Автоматизированное тестирование кода**: Автоматическая загрузка и выполнение фрагментов кода 1С
- **Бенчмаркинг производительности**: Измерение времени выполнения и метрик производительности
- **Пакетная обработка**: Выполнение нескольких тестовых образцов последовательно
- **Анализ результатов**: Парсинг и анализ логов выполнения
- **Интеграция с базой данных**: Бесшовная интеграция с базами данных 1С:Предприятие

## Структура проекта

```
bench/
├── bench/                    # Основные модули бенчмаркинга
│   ├── benchmark_runner.py   # Основная логика выполнения бенчмарков
│   ├── one_c_runner.py        # Интеграция с 1С:Предприятие
│   ├── one_c_parser.py        # Парсер логов 1С
│   ├── models.py              # Модели данных
│   ├── constants.py           # Константы конфигурации
│   ├── build_context_json.py  # Построение контекста в JSON
│   └── syntax_parser/         # Синтаксический анализатор
├── data/                      # Тестовые данные и шаблоны
│   ├── SampleProcessor.epf    # Шаблон внешней обработки
│   ├── stage_tasks.csv        # Задачи для стадий
│   ├── task_*.json            # Описания задач в JSON
│   ├── task_*.epf             # Внешние обработки задач
│   ├── output/                # Результаты выполнения
│   └── logs/                  # Логи выполнения
├── tasks/                     # Задачи бенчмарка
│   ├── task_001.epf           # Задача #1
│   ├── task_sample.epf        # Образец обработки задачи
│   └── ...                    # Другие задачи (task_002-010.epf)
├── processing_storage/        # Хранилище распакованных обработок
├── logs/                      # Системные логи
├── SampleOpener.epf           # Утилита для открытия обработок
├── playground.py              # Скрипт для тестирования и разработки
└── requirements.txt           # Зависимости Python
```

## Требования

- Python 3.8+
- Платформа 1С:Предприятие (рекомендуется 8.3.24+)
- Необходимые пакеты Python:
  - pandas
  - tqdm
  - python-dotenv

## Установка

0. Если у вас еще не становлена платформа 1С:Предприятие, установите ее согласно [официальной документации](https://online.1c.ru/catalog/free/34553751/).
1. Клонируйте репозиторий
2. Установите необходимые пакеты:
   ```bash
   pip install -r requirements.txt
   ```
3. Создайте файл `.env` на основе `.env.example`:
   ```bash
   cp .env.example .env
   ```
4. Настройте переменные окружения в файле `.env` (см. раздел "Конфигурация")

## Конфигурация

Настройка осуществляется через файл `.env` в корне проекта. После установки скопируйте `.env.example` в `.env` и обновите следующие переменные окружения:

### Обязательные переменные:

- `DESIGNER_PATH`: Путь к исполняемому файлу конфигуратора 1С:Предприятие
  ```
  DESIGNER_PATH=<путь к папке с 1С>/bin/1cv8.exe
  ```

- `DATABASE_PATH`: Путь к вашей базе данных 1С
  ```
  DATABASE_PATH=<ваш_путь_к_базе_данных>
  ```


### Дополнительные переменные:

- `PROCESSING_NAME`: Имя обработки (по умолчанию: `SampleProcessor`)
- `USER_NAME`: Имя пользователя 1С (по умолчанию: `Admin`)

**Примечание**: Файл `.env` содержит конфиденциальную информацию и не должен коммититься в репозиторий. Используйте `.env.example` как шаблон для новых установок.

## Использование

### Базовое использование

```python
from bench.benchmark_runner import BenchmarkRunner

# Инициализация запускателя бенчмарков
runner = BenchmarkRunner()

# Запуск бенчмарка на тестовом файле
results = runner.run("test_samples.csv")
```

### Формат данных образцов

Тестовые образцы должны предоставляться в виде обработки (**.epf**) со следующими функциями в модуле:
- `ваша_функция_решения()`: Код, идельно решающий задачу (для пробного запуска)
- `ЗадачаРешена()`: Код для валидации результатов
- `ЗапуститьРешение()`: подготовка данных и запуск решения

**Образец обработки для задачи бенчмарка**: `tasks\task_sample.epf` — пример структуры обработки с реализацией всех необходимых функций.

### Запуск бенчмарков

```python
# Запуск с пользовательскими параметрами
runner = BenchmarkRunner()
results = runner.run(
    filename="my_tests.csv",
    dry_run=False  # Установите True для режима валидации
)
```

## Разработка

### Запуск тестов

Используйте скрипт `playground.py` для разработки и тестирования:

```bash
python playground.py
```

### Добавление новых тестовых случаев

1. Создайте тестовые образцы в формате CSV
2. Включите необходимые фрагменты кода 1С
3. Добавьте логику валидации
4. Запустите через систему бенчмаркинга

## Архитектура

Система состоит из нескольких ключевых компонентов:

- **BenchmarkRunner**: Организует весь процесс бенчмаркинга
- **OneCEngine**: Обрабатывает операции с базой данных 1С:Предприятие
- **Sample Processor**: Внешняя обработка 1С для выполнения кода

## Соображения производительности

- Каждый тест выполняется с настраиваемым таймаутом (по умолчанию: 2 минуты)
- Операции с базой данных оптимизированы для пакетной обработки
- Логи парсятся для извлечения метрик производительности

## Устранение неполадок

### Распространенные проблемы

1. **Ошибки разрешений**: Убедитесь, что 1С:Предприятие имеет соответствующие разрешения
2. **Проблемы с кодировкой**: Файлы должны быть сохранены в кодировке UTF-8
3. **Конфигурация путей**: Проверьте правильность всех путей в файле `.env`

### Режим отладки

Включите вывод отладочной информации, раскомментировав операторы print в модулях запускателя.

## Анализ логов

Система парсит логи выполнения 1С для определения:
- **Статус компиляции**: Успешно ли скомпилировался код
- **Статус выполнения**: Выполнился ли код без ошибок
- **Валидация результата**: Соответствует ли вывод ожидаемым результатам

## Участие в разработке

1. Сделайте форк репозитория
2. Создайте ветку функциональности
3. Добавьте тесты для новой функциональности
4. Отправьте pull request
